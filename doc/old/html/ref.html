<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
               "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"
lang="en" xml:lang="en">
<head>
<title>Sferes2 &ndash; reference</title>
<meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>
<meta name="generator" content="Org-mode"/>
<meta name="generated" content="2010-01-31 20:59:49 CET"/>
<meta name="author" content="Jean-Baptiste Mouret"/>
<meta name="description" content=""/>
<meta name="keywords" content=""/>
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  html { font-family: Times, serif; font-size: 12pt; }
  .title  { text-align: center; }
  .todo   { color: red; }
  .done   { color: green; }
  .tag    { background-color: #add8e6; font-weight:normal }
  .target { }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  p.verse { margin-left: 3% }
  pre {
	border: 1pt solid #AEBDCC;
	background-color: #F3F5F7;
	padding: 5pt;
	font-family: courier, monospace;
        font-size: 90%;
        overflow:auto;
  }
  table { border-collapse: collapse; }
  td, th { vertical-align: top; }
  dt { font-weight: bold; }
  div.figure { padding: 0.5em; }
  div.figure p { text-align: center; }
  .linenr { font-size:smaller }
  .code-highlighted {background-color:#ffff00;}
  .org-info-js_info-navigation { border-style:none; }
  #org-info-js_console-label { font-size:10px; font-weight:bold;
                               white-space:nowrap; }
  .org-info-js_search-highlight {background-color:#ffff00; color:#000000;
                                 font-weight:bold; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="../css/stylesheet.css" />
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Sferes2 &ndash; reference</h1>

<p><a href="sferes2.html">{back to main page}</a>
</p>

<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">1 The Sferes2 framework </a>
<ul>
<li><a href="#sec-1.1">1.1 Main concepts </a>
<ul>
<li><a href="#sec-1.1.1">1.1.1 Static object-oriented paradigm </a></li>
<li><a href="#sec-1.1.2">1.1.2 Static parameters </a></li>
<li><a href="#sec-1.1.3">1.1.3 Macros and special functions </a>
<ul>
<li><a href="#sec-1.1.3.1">1.1.3.1 Classes </a></li>
<li><a href="#sec-1.1.3.2">1.1.3.2 Parameter handling </a></li>
</ul></li>
</ul>
</li>
<li><a href="#sec-1.2">1.2 Mastering boost </a></li>
<li><a href="#sec-1.3">1.3 UML Diagram </a></li>
<li><a href="#sec-1.4">1.4 Overview of the call graph </a></li>
</ul>
</li>
<li><a href="#sec-2">2 Main classes and files </a>
<ul>
<li><a href="#sec-2.1">2.1 Naming conventions </a></li>
<li><a href="#sec-2.2">2.2 Fitness </a>
<ul>
<li><a href="#sec-2.2.1">2.2.1 Fitness </a></li>
<li><a href="#sec-2.2.2">2.2.2 Defining your own fitness </a></li>
<li><a href="#sec-2.2.3">2.2.3 View mode </a></li>
</ul>
</li>
<li><a href="#sec-2.3">2.3 Evolutionary algorithms </a>
<ul>
<li><a href="#sec-2.3.1">2.3.1 Shared parameters </a></li>
<li><a href="#sec-2.3.2">2.3.2 RankSimple </a></li>
<li><a href="#sec-2.3.3">2.3.3 Nsga2 </a></li>
<li><a href="#sec-2.3.4">2.3.4 EpsMOEA </a></li>
<li><a href="#sec-2.3.5">2.3.5 Defining your own EA </a></li>
</ul>
</li>
<li><a href="#sec-2.4">2.4 Statistics </a>
<ul>
<li><a href="#sec-2.4.1">2.4.1 BestFit </a></li>
<li><a href="#sec-2.4.2">2.4.2 MeanFit </a></li>
<li><a href="#sec-2.4.3">2.4.3 ParetoFront </a></li>
<li><a href="#sec-2.4.4">2.4.4 Defining your own statistics </a></li>
</ul>
</li>
<li><a href="#sec-2.5">2.5 Genotypes </a>
<ul>
<li><a href="#sec-2.5.1">2.5.1 BitString </a></li>
<li><a href="#sec-2.5.2">2.5.2 EvoFloat </a></li>
<li><a href="#sec-2.5.3">2.5.3 Defining your own genotype </a></li>
</ul>
</li>
<li><a href="#sec-2.6">2.6 Phenotypes (Individuals) </a>
<ul>
<li><a href="#sec-2.6.1">2.6.1 Indiv </a></li>
<li><a href="#sec-2.6.2">2.6.2 Parameters </a></li>
<li><a href="#sec-2.6.3">2.6.3 Defining your own phenotype </a></li>
</ul>
</li>
<li><a href="#sec-2.7">2.7 Evaluators </a>
<ul>
<li><a href="#sec-2.7.1">2.7.1 Eval </a></li>
<li><a href="#sec-2.7.2">2.7.2 Parallel </a></li>
<li><a href="#sec-2.7.3">2.7.3 Mpi </a></li>
<li><a href="#sec-2.7.4">2.7.4 Defining your own evaluator </a></li>
</ul>
</li>
<li><a href="#sec-2.8">2.8 Modifiers </a>
<ul>
<li><a href="#sec-2.8.1">2.8.1 Dummy </a></li>
</ul>
</li>
<li><a href="#sec-2.9">2.9 Misc </a></li>
</ul>
</li>
<li><a href="#sec-3">3 Modules </a>
<ul>
<li><a href="#sec-3.1">3.1 NN </a></li>
<li><a href="#sec-3.2">3.2 Fastsim </a></li>
<li><a href="#sec-3.3">3.3 Python </a></li>
</ul>
</li>
<li><a href="#sec-4">4 Writing modules </a></li>
</ul>
</div>
</div>

<div id="outline-container-1" class="outline-2">
<h2 id="sec-1"><span class="section-number-2">1</span> The Sferes2 framework </h2>
<div class="outline-text-2" id="text-1">


</div>

<div id="outline-container-1.1" class="outline-3">
<h3 id="sec-1.1"><span class="section-number-3">1.1</span> Main concepts </h3>
<div class="outline-text-3" id="text-1.1">


</div>

<div id="outline-container-1.1.1" class="outline-4">
<h4 id="sec-1.1.1"><span class="section-number-4">1.1.1</span> Static object-oriented paradigm </h4>
<div class="outline-text-4" id="text-1.1.1">

<p>Object-oriented programming (OOP) has many advantages which are
desirable for complex high-level code. However, classic OOP (e.g. in
C++) heavily relies on virtual methods to implement abstraction and
polymorphism. Such an approach has a significant run-time overhead:
</p><ul>
<li>
selecting the good method to call adds an indirection (the software
have to check the virtual table)
</li>
<li>
abstract/virtual methods cannot be inlined, resulting in a overhead
for very simple methods (e.g. setters/getters).

</li>
</ul>

<p>In a few word, we want the main benefits of OOP (abstraction,
re-usability) and the efficiency of low-level languages.
</p>
<p>
One solution in C++ is to use the "curiously recurring template
pattern"
(<a href="http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern">http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern</a>). Here
is the idea:
</p>


<pre class="src src-c++"><span class="org-keyword">template</span> &lt;<span class="org-keyword">class</span> <span class="org-type">Derived</span>&gt; <span class="org-keyword">struct</span> <span class="org-type">Base</span>
{
    <span class="org-type">void</span> <span class="org-function-name">interface</span>()
    {
        <span class="org-keyword">static_cast</span>&lt;Derived*&gt;(<span class="org-keyword">this</span>)-&gt;implementation();
    }
    <span class="org-type">void</span> <span class="org-function-name">f</span>()
    {
       <span class="org-keyword">for</span>(<span class="org-type">int</span> <span class="org-variable-name">i</span> = 0; i &lt; 3; ++i) interface();
    }
};
 
<span class="org-keyword">struct</span> <span class="org-type">Derived</span> : <span class="org-type">Base</span>&lt;<span class="org-type">Derived</span>&gt;
{
    <span class="org-type">void</span> <span class="org-function-name">implementation</span>() { <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"impl"</span>&lt;&lt;<span class="org-constant">std</span>::endl; }
};
</pre>




<p>
This code mimics a virtual call of an abstract method: in the abstract
class (Base), a generic algorithm can use methods which are only
defined in the derived classes. Extending this pattern to draw a full
hierarchy of classes requires more work; sferes2 relies on the method
described in the following paper:
</p>
<p>
Nicolas Burrus, Alexandre Duret-Lutz, Thierry Géraud, David Lesage
and Raphaël Poss. A Static C++ Object-Oriented Programming (SCOOP)
Paradigm Mixing Benefits of Traditional OOP and Generic
Programming. In <i>Proceedings of the Workshop on Multiple Paradigm with OO Languages (MPOOL'03)</i>, 2003.
<a href="http://www.lrde.epita.fr/dload/papers/mpool03.pdf">http://www.lrde.epita.fr/dload/papers/mpool03.pdf</a>
</p>
<p>
This mechanics is hidden in sferes2 behind some macros (see section <a href="#sec-1.1.3">macros</a>)
</p>
</div>

</div>

<div id="outline-container-1.1.2" class="outline-4">
<h4 id="sec-1.1.2"><span class="section-number-4">1.1.2</span> Static parameters </h4>
<div class="outline-text-4" id="text-1.1.2">

<p>Evolutionary algorithms have a lot of parameters (e.g. population
size, mutation rate, etc.) and we need a convenient way to set them. A
configuration file (e.g. an XML file) is often used; however, such a
method has two drawbacks:
</p><ul>
<li>
some code to read the files has to be written and kept synchronized
with the objects;
</li>
<li>
parameters are unknown at compile time so some checks (e.g. if
(mutation_type = x) {} else { } &hellip;) have to be done many times
whereas they are useless.

</li>
</ul>

<p>In sferes2, parameters are defined at compile time using a structure
which contains only constants. This structure is passed to all sferes2
classes so they can access to the parameters. This method allows to
avoid to write read/write code for parameters. It also allows the
compiler to propagate constants and settings in the whole source code,
resulting in an executable optimized for the specific parameters.
</p>
</div>

</div>

<div id="outline-container-1.1.3" class="outline-4">
<h4 id="sec-1.1.3"><a name="macros" id="macros"></a><span class="section-number-4">1.1.3</span> Macros and special functions </h4>
<div class="outline-text-4" id="text-1.1.3">

<p>To simplify the writing of "static virtual functions" and the
definition of static parameters, sferes2 provides several macros which
are defined in <a href="../../sferes/stc.hpp">stc.hpp</a>.
</p>

</div>

<div id="outline-container-1.1.3.1" class="outline-5">
<h5 id="sec-1.1.3.1"><span class="section-number-5">1.1.3.1</span> Classes </h5>
<div class="outline-text-5" id="text-1.1.3.1">

<ul>
<li>
SFERES_CLASS(Name): defines the base class Name ; this class uses
the "static" inheritance scheme and takes a Param template parameter.
</li>
<li>
SFERES_CLASS_D(Name, Parent): derives the class Name from Parent
</li>
<li>
SFERES_PARENT(Name, Parent)::method(): calls method() in the parent class
</li>
<li>
stc::exact(this)-&gt;method(): calls an abstract method() which is
defined in the derived classes

</li>
</ul>

<p>Moreover, sferes2 provides special macros to define specific classes
(SFERES_FITNESS, SFERES_INDIV, SFERES_EA, etc.). See <a href="#sec-2">ref</a>.
</p>
<p>
Example:
</p>


<pre class="src src-c++"><span class="org-function-name">SFERES_CLASS</span>(X)
{
  <span class="org-variable-name">X</span>() { <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"X"</span>&lt;&lt;<span class="org-constant">std</span>::endl; }
  <span class="org-type">void</span> <span class="org-variable-name">test</span>() { <span class="org-constant">stc</span>::exact(<span class="org-keyword">this</span>)-&gt;blah(); }
  <span class="org-type">void</span> <span class="org-variable-name">test2</span>() { <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"test2"</span>&lt;&lt;<span class="org-constant">std</span>::endl; }
};
<span class="org-comment-delimiter">// </span><span class="org-comment">Y derives from X
</span><span class="org-function-name">SFERES_CLASS_D</span>(Y, X)
{
  <span class="org-variable-name">Y</span>() { <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"Y"</span>&lt;&lt;<span class="org-constant">std</span>::endl; }
  <span class="org-type">void</span> <span class="org-variable-name">blah</span>() 
  { 
    <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"param::test::x"</span>&lt;&lt;<span class="org-constant">Param</span>::<span class="org-constant">test</span>::x&lt;&lt;<span class="org-constant">std</span>::endl;
    <span class="org-variable-name">SFERES_PARENT</span>(Y, X)::test2();
  }
};
<span class="org-comment-delimiter">// </span><span class="org-comment">Z derives from Y
</span><span class="org-function-name">SFERES_CLASS_D</span>(Z, Y)
{
  <span class="org-variable-name">Z</span>() { <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"Z"</span>&lt;&lt;<span class="org-constant">std</span>::endl; }
  <span class="org-type">void</span> <span class="org-variable-name">blah</span>() 
  { 
    <span class="org-constant">std</span>::cout&lt;&lt;<span class="org-string">"Z"</span>&lt;&lt;<span class="org-constant">std</span>::endl;
  }
};
<span class="org-comment-delimiter">// </span><span class="org-comment">sample parameter (see next subsection)
</span><span class="org-keyword">struct</span> <span class="org-type">Params_test</span>
{
  <span class="org-keyword">struct</span> <span class="org-type">test</span>
  {
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">x</span> = 0.1f;
  };
};
<span class="org-comment-delimiter">// </span><span class="org-comment">to instantiate Y and Z (X is abstract):
</span><span class="org-type">int</span> <span class="org-function-name">main</span>()
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">Y uses a parameter
</span>  <span class="org-type">Y</span>&lt;Param_test&gt; <span class="org-variable-name">y</span>;
  <span class="org-comment-delimiter">// </span><span class="org-comment">Z doesn't use any parameter, these two forms are possible:
</span>  <span class="org-type">Z</span>&lt;&gt; <span class="org-variable-name">z1</span>;
  <span class="org-type">Z</span>&lt;Param_test&gt; <span class="org-variable-name">z2</span>;
  <span class="org-keyword">return</span> 0;
}
</pre>



</div>

</div>

<div id="outline-container-1.1.3.2" class="outline-5">
<h5 id="sec-1.1.3.2"><span class="section-number-5">1.1.3.2</span> Parameter handling </h5>
<div class="outline-text-5" id="text-1.1.3.2">

<p>The basic parameter format employs static const members in nested
structures. For instance:
</p>


<pre class="src src-c++"><span class="org-keyword">struct</span> <span class="org-type">Param</span>
{
  <span class="org-keyword">struct</span> <span class="org-type">pop</span>
  {
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">size</span> = 100;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">x</span> = 0.2f;
  };
};
</pre>



<p>
However, c++ does not allow to define static const string or arrays in
these structures. To solve this problem, sferes2 provides two macros:
</p><ul>
<li>
SFERES_ARRAY(type, name, val1, val2, &hellip;)
</li>
<li>
SFERES_STRING(name, "string")

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">struct</span> <span class="org-type">Param</span>
{
  <span class="org-keyword">struct</span> <span class="org-type">test</span>
  {
    SFERES_ARRAY(<span class="org-type">float</span>, my_array, 1.0f, 2.0f, 3.0f);
    SFERES_STRING(my_string, <span class="org-string">"hello world"</span>);
  };
};
</pre>



<p>
These parameters can then be retrieved in the source code in the
following way:
</p>


<pre class="src src-c++">...
<span class="org-comment-delimiter">// </span><span class="org-comment">size
</span>size_t s = <span class="org-constant">Params</span>::<span class="org-constant">test</span>::my_array_size();
<span class="org-comment-delimiter">// </span><span class="org-comment">2nd element
</span><span class="org-type">float</span> <span class="org-variable-name">v</span> = <span class="org-constant">Param</span>::<span class="org-constant">test</span>::my_array(2);
<span class="org-comment-delimiter">// </span><span class="org-comment">string
</span><span class="org-keyword">const</span> <span class="org-type">char</span>* <span class="org-variable-name">c</span> = <span class="org-constant">Params</span>::<span class="org-constant">test</span>::my_string();
</pre>




</div>
</div>
</div>

</div>

<div id="outline-container-1.2" class="outline-3">
<h3 id="sec-1.2"><span class="section-number-3">1.2</span> Mastering boost </h3>
<div class="outline-text-3" id="text-1.2">

<p>Sferes2 heavily relies on boost libraries (see
<a href="http://www.boost.org">http://www.boost.org</a>). To implement your own
algorithms in the sferes2 framework, you should be familiar enough
with the following libraries:
</p><ul>
<li>
boost::shared_ptr:
<a href="http://www.boost.org/doc/libs/1_40_0/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/doc/libs/1<sub>40</sub><sub>0</sub>/libs/smart<sub>ptr</sub>/shared<sub>ptr</sub>.htm</a>
</li>
<li>
boost::serialization (useful to define your own genotypes and
statistics):
<a href="http://www.boost.org/doc/libs/1_40_0/libs/serialization/doc/index.html">http://www.boost.org/doc/libs/1<sub>40</sub><sub>0</sub>/libs/serialization/doc/index.html</a>

</li>
</ul>

<p>The following libraries are used in sferes2 but you might never notice
them:
</p><ul>
<li>
BOOST_FOREACH (to simplify loops): <a href="http://www.boost.org/doc/libs/1_40_0/doc/html/foreach.html">http://www.boost.org/doc/libs/1<sub>40</sub><sub>0</sub>/doc/html/foreach.html</a>
</li>
<li>
boost::filesystem (to create directories, etc.): <a href="http://www.boost.org/doc/libs/1_40_0/libs/filesystem/doc/index.htm">http://www.boost.org/doc/libs/1<sub>40</sub><sub>0</sub>/libs/filesystem/doc/index.htm</a>
</li>
<li>
boost::fusion (list of statistics):
<a href="http://www.boost.org/doc/libs/1_40_0/libs/fusion/doc/html/index.html">http://www.boost.org/doc/libs/1<sub>40</sub><sub>0</sub>/libs/fusion/doc/html/index.html</a>
</li>
<li>
boost::mpi (MPI evaluator): <a href="http://www.boost.org/doc/libs/1_40_0/doc/html/mpi.html">http://www.boost.org/doc/libs/1<sub>40</sub><sub>0</sub>/doc/html/mpi.html</a>
</li>
</ul>
</div>

</div>

<div id="outline-container-1.3" class="outline-3">
<h3 id="sec-1.3"><span class="section-number-3">1.3</span> UML Diagram </h3>
<div class="outline-text-3" id="text-1.3">

<p>Here is a "conceptual" UML diagram of the sferes2 framework (modules
are not represented). It's "conceptual" because some abstract classes
are not implemented (because they are useless from an implementation
point of view) but should exist in the mind of the user. Moreover,
each class is parametrized by the Param class (see previous section),
which is not represented on the diagram.
</p>

<div class="figure">
<p><img src="../img/sferes.jpg"  alt="../img/sferes.jpg" /></p>
</div>

</div>

</div>

<div id="outline-container-1.4" class="outline-3">
<h3 id="sec-1.4"><span class="section-number-3">1.4</span> Overview of the call graph </h3>
<div class="outline-text-3" id="text-1.4">



<div class="figure">
<p><img src="../img/call_graph.jpg"  alt="../img/call_graph.jpg" /></p>
</div>

<p>
On this simplified call graph:
</p><ul>
<li>
ea_t : type of your EA (e.g. ea::Nsga2)
</li>
<li>
eval_t : type of your evaluator (e.g. eval::Parallel)
</li>
<li>
gen_t : type of your phenotype (e.g gen::EvoFloat)
</li>
<li>
modifier_t : type of your modifier (e.g. modif::Dummy)
</li>
<li>
phen_t : type of your phenotype (e.g. phen::Parameters)
</li>
<li>
stat_t : type of your statistics vector
(e.g. boost::fusion::vector&lt;stat::BestFit&lt;phen_t&gt; &gt; )

</li>
</ul>

<p>Time flows from left to right (i.e. random_pop() is called before
epoch() and so on). Methods with a double bar are called for each individual or
each new individual.
</p>
</div>
</div>

</div>

<div id="outline-container-2" class="outline-2">
<h2 id="sec-2"><a name="ref" id="ref"></a><span class="section-number-2">2</span> Main classes and files </h2>
<div class="outline-text-2" id="text-2">


</div>

<div id="outline-container-2.1" class="outline-3">
<h3 id="sec-2.1"><span class="section-number-3">2.1</span> Naming conventions </h3>
<div class="outline-text-3" id="text-2.1">

<ul>
<li>
Names representing <b>classes</b> must be in mixed case starting with upper
case: MyClass
</li>
<li>
<b>Variable and method names</b> must be in lower case, using underscores to
separate words: my_variable, my_method()
</li>
<li>
Names of <b>protected and private members</b> must start with an underscore:
_my_private_member, _my_private_method()
</li>
<li>
<b>File names</b> must be in lower case, using underscores to separate
words. A file which contains a class MyClass should be put in a file
my_class.hpp
</li>
<li>
<b>File structure</b> mirrors namespace structure. For instance
gen::MyClass is in the file gen/my_class.hpp
</li>
<li>
<b>Named constants</b> (including enumeration values) must be all uppercase
using underscores to separate words
</li>
<li>
<b>Getters</b> should have the name of the attribute. For instance,
this-&gt;_objs should be accessed using this-&gt;objs()
</li>
<li>
<b>Setters</b> should start with "set_" followed by the name of
the attribute. For instance: set_objs(const std::vector&lt;float&gt;&amp; ov)
</li>
<li>
The <b>public section</b> should be the first section of a class
</li>
<li>
Type names defined using <b>typedefs</b> should end with _t (e.g. iterator_t) 
</li>
</ul>

<p>Full example:
</p>


<pre class="src src-c++"><span class="org-comment-delimiter">// </span><span class="org-comment">filename: sferes/fit/my_test.hpp
</span><span class="org-keyword">namespace</span> <span class="org-constant">sferes</span>
{
  <span class="org-keyword">namespace</span> <span class="org-constant">fit</span>
  {
    <span class="org-keyword">class</span> <span class="org-type">SFERES_CLASS</span>(MyTest)
    {
    <span class="org-keyword">public</span>:
      <span class="org-keyword">typedef</span> <span class="org-type">float</span> <span class="org-type">f_t</span>;
      <span class="org-variable-name">MyTest</span>() {}
      <span class="org-type">void</span> <span class="org-variable-name">my_method</span>() { _my_impl(); }
      <span class="org-type">float</span> <span class="org-variable-name">my_attr</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> _my_attr;}
      <span class="org-type">float</span> <span class="org-variable-name">set_my_attr</span>(<span class="org-type">float</span> <span class="org-variable-name">a</span>) { _my_attr = v; }
    <span class="org-keyword">protected</span>:
      <span class="org-type">float</span> <span class="org-variable-name">_my_attr</span>;
      <span class="org-type">void</span> <span class="org-variable-name">_my_impl</span>() {}
    };
  }
}
</pre>




</div>

</div>

<div id="outline-container-2.2" class="outline-3">
<h3 id="sec-2.2"><span class="section-number-3">2.2</span> Fitness </h3>
<div class="outline-text-3" id="text-2.2">


</div>

<div id="outline-container-2.2.1" class="outline-4">
<h4 id="sec-2.2.1"><span class="section-number-4">2.2.1</span> Fitness </h4>
<div class="outline-text-4" id="text-2.2.1">

<ul>
<li>
<b>File:</b> <a href="/home/mandor/svn/sferes2/trunk/sferes/fit/fitness.hpp">sferes/fit/fitness.hpp</a>
</li>
<li>
<b>Description:</b> Fitness is the base class of fitness functions in
sferes2. It has two main attributes:
<ul>
<li>
float _value (setter/getter Fitness::value()) -&gt; the value of the fitness for
single-objective optimization
</li>
<li>
std::vector&lt;float&gt; _objs (setter/getter Fitness::objs()) -&gt; the value of
each objective, for multiobjective optimization
</li>
</ul>
</li>
<li>
This class is abstract
</li>
</ul>
</div>

</div>

<div id="outline-container-2.2.2" class="outline-4">
<h4 id="sec-2.2.2"><span class="section-number-4">2.2.2</span> Defining your own fitness </h4>
<div class="outline-text-4" id="text-2.2.2">

<p>In most sferes2 experiments, you will have to design your own fitness. A
fitness should:
</p><ul>
<li>
be defined using SFERES_FITNESS(MyFitness, sferes::fit::Fitness)
</li>
<li>
define the eval() method, which takes an individual
</li>
<li>
attribute a fitness value in this-&gt;_value (single objective
optimization) or this-&gt;_objs (multiobjective optimization)

<p>
A fitness is a "normal" class and consequently you can
add other methods or attributes to suit your needs.
</p>
</li>
</ul>

<p>Example:
</p>


<pre class="src src-c++"><span class="org-comment-delimiter">// </span><span class="org-comment">single objective fitess
</span><span class="org-function-name">SFERES_FITNESS</span>(FitnessSingle, <span class="org-constant">sferes</span>::<span class="org-constant">fit</span>::fitness)
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">(optional) constructor
</span>  <span class="org-variable-name">FitnessSingle</span>()
    {
      <span class="org-keyword">this</span>-&gt;_value = -1;
    }
  <span class="org-comment-delimiter">// </span><span class="org-comment">evaluation
</span>  <span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Indiv</span>&gt;
    <span class="org-type">void</span> <span class="org-variable-name">eval</span>(<span class="org-type">Indiv</span>&amp; <span class="org-variable-name">indiv</span>)
  {
    <span class="org-keyword">this</span>-&gt;_value = -42;
  }
};

<span class="org-comment-delimiter">// </span><span class="org-comment">two-objective fitness
</span><span class="org-function-name">SFERES_FITNESS</span>(FitnessMulti, <span class="org-constant">sferes</span>::<span class="org-constant">fit</span>::fitness)
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">constructor
</span>  <span class="org-variable-name">FitnessMulti</span>()
    {
      <span class="org-keyword">this</span>-&gt;_objs.resize(2);   
    }
  <span class="org-comment-delimiter">// </span><span class="org-comment">evaluation
</span>  <span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Indiv</span>&gt;
    <span class="org-type">void</span> <span class="org-variable-name">eval</span>(<span class="org-type">Indiv</span>&amp; <span class="org-variable-name">indiv</span>)
  {
    <span class="org-keyword">this</span>-&gt;_objs[0] = -42;
    <span class="org-keyword">this</span>-&gt;_objs[1] = 42;
  }
};
</pre>



</div>

</div>

<div id="outline-container-2.2.3" class="outline-4">
<h4 id="sec-2.2.3"><span class="section-number-4">2.2.3</span> View mode </h4>
<div class="outline-text-4" id="text-2.2.3">

<p>When loading a result file, it is often useful to slightly change the
fitness function, for instance to display/log data about the behavior
of the individual. This can be easily done in sferes2 using the
boolean Fitness::mode() than can takes two values:
</p><ul>
<li>
fit::mode::view when you are viewing an individual via &ndash;load
</li>
<li>
fit::mode::eval when you are evaluting individuals (during the
evolutionary process)
</li>
</ul>

<p>Example:
</p>


<pre class="src src-c++"><span class="org-comment-delimiter">// </span><span class="org-comment">single objective fitess
</span><span class="org-function-name">SFERES_FITNESS</span>(FitnessSingle, <span class="org-constant">sferes</span>::<span class="org-constant">fit</span>::fitness)
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">evaluation
</span>  <span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Indiv</span>&gt;
    <span class="org-type">void</span> <span class="org-variable-name">eval</span>(<span class="org-type">Indiv</span>&amp; <span class="org-variable-name">indiv</span>)
  {
    <span class="org-keyword">if</span> (<span class="org-keyword">this</span>-&gt;mode() == <span class="org-constant">sferes</span>::<span class="org-constant">fit</span>::<span class="org-constant">mode</span>::view)
      {
      <span class="org-constant">std</span>::<span class="org-type">ofstream</span> <span class="org-variable-name">ofs</span>(<span class="org-string">"fit.dat"</span>);
      ofs&lt;&lt;<span class="org-string">"this is a log file !"</span>&lt;&lt;<span class="org-constant">std</span>::endl;
      }
    <span class="org-keyword">this</span>-&gt;_value = -42;
  }
};
</pre>



</div>
</div>

</div>

<div id="outline-container-2.3" class="outline-3">
<h3 id="sec-2.3"><span class="section-number-3">2.3</span> Evolutionary algorithms </h3>
<div class="outline-text-3" id="text-2.3">

<p><b>Warning</b> Evolutionary algorithms <i>maximize</i> the fitness (whereas most
optimization algorithms minimize the cost function).
</p>
</div>

<div id="outline-container-2.3.1" class="outline-4">
<h4 id="sec-2.3.1"><span class="section-number-4">2.3.1</span> Shared parameters </h4>
<div class="outline-text-4" id="text-2.3.1">

<p>All evolutionary algorithms (EA) use the following parameters:
</p><ul>
<li>
static const size_t Params::pop::size = population size
</li>
<li>
static const float Params::pop::initial_aleat = during the random generation,
Params::pop::initial_aleat &times; Params::pop::size individuals are
generated and only the Params::pop::size best ones are kept
</li>
<li>
static const int Params::pop::dump_period: the period between each write of results, examples:
<ul>
<li>
1: statistics are written at each generation (gen_0, gen_1, gen_2, &hellip;)
</li>
<li>
-1: statistics are never written (useful for unit tests)
</li>
<li>
10: statistics are written each 10 generations (gen_0, gen_10, &hellip;)
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2.3.2" class="outline-4">
<h4 id="sec-2.3.2"><span class="section-number-4">2.3.2</span> RankSimple </h4>
<div class="outline-text-4" id="text-2.3.2">

<ul>
<li>
<b>File:</b> <a href="/home/mandor/svn/sferes2/trunk/sferes/ea/rank_simple.hpp">sferes/ea/rank_simple.hpp</a>
</li>
<li>
<b>Unit test:</b> <a href="/home/mandor/svn/sferes2/trunk/tests/ea/rank_simple.cpp">tests/ea/rank_simple.cpp</a>
</li>
<li>
<b>Typical typename:</b>: 

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-constant">sferes</span>::<span class="org-constant">ea</span>::<span class="org-type">RankSimple</span>&lt;<span class="org-type">phen_t</span>, <span class="org-type">eval_t</span>, <span class="org-type">stat_t</span>, <span class="org-type">modifier_t</span>, Params&gt; <span class="org-type">ea_t</span>;
</pre>




<ul>
<li>
<b>Description:</b> A rank-based single-objective evolutionary
algorithm. Individuals are selected using the following formula:
<ul>
<li>
n = k<sub>r</sub> &times; p
</li>
<li>
&kappa; = c<sup>n + 1</sup> - 1
</li>
<li>
f = n / (&kappa; + 1)
</li>
<li>
i = p - f &times; log(r &times; &kappa; + 1)
</li>
<li>
where
<ul>
<li>
c = Params::pop::coeff
</li>
<li>
k<sub>r</sub> = Params::pop::keep_rate
</li>
<li>
p = Params::pop::size
</li>
<li>
r = a random number in [0,1[
</li>
<li>
i = index of the selected individual

</li>
</ul>
</li>
</ul>
</li>
<li>
parameters:
<ul>
<li>
static const float Params::pop::coeff = a internal parameter (see the previous
formula) ; typical value : 1.1
</li>
<li>
static const float Params::pop::keep_rate = proportion of individuals kept from a
generation to the next one ; typical value : 0.2 to 0.6

</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2.3.3" class="outline-4">
<h4 id="sec-2.3.3"><span class="section-number-4">2.3.3</span> Nsga2 </h4>
<div class="outline-text-4" id="text-2.3.3">

<ul>
<li>
<b>File:</b> <a href="../../sferes/ea/nsga2.hpp">sferes/ea/nsga2.hpp</a>
</li>
<li>
<b>Unit test:</b> <a href="/home/mandor/svn/sferes2/trunk/tests/ea/nsga2.cpp">tests/ea/nsga2.cpp</a>
</li>
<li>
Example: <a href="/home/mandor/svn/sferes2/trunk/examples/ex_nsga2.cpp">examples/ex_nsga2.cpp</a>
</li>
<li>
<b>Typical typename:</b>: 

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-constant">sferes</span>::<span class="org-constant">ea</span>::<span class="org-type">Nsga2</span>&lt;<span class="org-type">phen_t</span>, <span class="org-type">eval_t</span>, <span class="org-type">stat_t</span>, <span class="org-type">modifier_t</span>, Params&gt; <span class="org-type">ea_t</span>;
</pre>



<ul>
<li>
<b>Description:</b> Implementation of the NSGA-II multiobjective
evolutionary algorithm. See:
<ul>
<li>
Deb, K. (2001). Multi-Objective Optimization Using Evolutionary
Algorithms. <i>Wiley</i>.
</li>
<li>
Deb, K., Pratap, A., Agarwal, S. and Meyarivan, T. (2002). A fast
and elitist multiobjective genetic algorithm: NSGA-II. In <i>IEEE    transactions on evolutionary computation</i>, 6:2:182-197
</li>
</ul>
</li>
<li>
<b>Parameters:</b> pop_size must be divisible by 4
</li>
<li>
<b>Note:</b> NSGA-II can be efficient for single-objective optimization as
it corresponds to a classic tournament-based evolutionary algorithm. In
sferes2, a 1-sized _objs vector in the fitness can be employed (don't
use <sub>value</sub>).
</li>
</ul>
</div>

</div>

<div id="outline-container-2.3.4" class="outline-4">
<h4 id="sec-2.3.4"><span class="section-number-4">2.3.4</span> EpsMOEA </h4>
<div class="outline-text-4" id="text-2.3.4">

<ul>
<li>
<b>File:</b> <a href="../../sferes/ea/eps_moea.hpp">sferes/ea/eps_moea.hpp</a>
</li>
<li>
<b>Unit test:</b> <a href="/home/mandor/svn/sferes2/trunk/tests/ea/eps_moea.cpp">tests/ea/eps_moea.cpp</a>
</li>
<li>
<b>Typical typename:</b>: 

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-constant">sferes</span>::<span class="org-constant">ea</span>::<span class="org-type">EpsMOEA</span>&lt;<span class="org-type">phen_t</span>, <span class="org-type">eval_t</span>, <span class="org-type">stat_t</span>, <span class="org-type">modifier_t</span>, Params&gt; <span class="org-type">ea_t</span>
</pre>



<ul>
<li>
<b>Description:</b> Implementation of the &epsilon;-MOEA multiobjective
evolutionary algorithm. See: 
<ul>
<li>
Deb, K., Mohan, M. and Mishra, S. (2005). Evaluating the
&epsilon;-domination based multi-objective evolutionary
algorithm for a quick computation of pareto-optimal solutions. In
<i>Evolutionary Computation</i>, 13:4:501-525.
</li>
</ul>
</li>
<li>
Parameters
<ul>
<li>
SFERES_ARRAY(float, eps, 0.0075f, 0.0075f) = values of &epsilon;
for each objective. There should be as many values as objectives.
</li>
<li>
SFERES_ARRAY(float, min_fit, 0.0f, 0.0f) = minimum value of
fitness for each objective.There should as many values as objectives
</li>
<li>
static const size_t grain = &epsilon;-MOEA is a
steady-state algorithm which adds individuals one by one. A basic
implementation would prevent the parallelization of individuals'
evaluation. The parameter grain allows to generate and evaluate
<i>grain</i> indidividuals in paralell at each generation. Typical value
is size / 4.
</li>
</ul>
</li>
<li>
<b>Notes:</b> 
<ul>
<li>
&epsilon;-MOEA employs &epsilon;-dominance to sort
individuals. This allows users to tune the precision of the pareto
front for each objective and often results in better performance
than NSGA-II.
</li>
<li>
EpsMOEA should not be used with a modifier (because it uses an
archive). You should always use fit::ModifierDummy
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2.3.5" class="outline-4">
<h4 id="sec-2.3.5"><span class="section-number-4">2.3.5</span> Defining your own EA </h4>
<div class="outline-text-4" id="text-2.3.5">

<p>To define your own EA, you should use the macro SFERES_EA(Class,
Parent). Mandatory methods:
</p><ul>
<li>
random_pop(): fill this-&gt;_pop with random individuals
</li>
<li>
epoch(): main loop of the algorithm
</li>
</ul>

<p>Defined types (these types will be available in your class):
</p><ul>
<li>
Phen: phenotype
</li>
<li>
Eval: evaluator
</li>
<li>
Stat: statistics vector
</li>
<li>
FitModifier: modifier
</li>
<li>
Params: parameters

</li>
</ul>


<pre class="src src-c++"><span class="org-function-name">SFERES_EA</span>(Test, Ea)
{
 <span class="org-keyword">public</span>:
 <span class="org-variable-name">Test</span>() {}
 <span class="org-type">void</span> <span class="org-variable-name">random_pop</span>()
 { <span class="org-comment-delimiter">/* </span><span class="org-comment">your code */</span> }
 <span class="org-type">void</span> <span class="org-variable-name">epoch</span>()
 { <span class="org-comment-delimiter">/* </span><span class="org-comment">your code */</span> }
};
</pre>



<p>
Multiobjective EA must also define a pareto_front() method, see <a href="#sec-2.4.3">ParetoFront</a>.
</p>
</div>
</div>

</div>

<div id="outline-container-2.4" class="outline-3">
<h3 id="sec-2.4"><span class="section-number-3">2.4</span> Statistics </h3>
<div class="outline-text-3" id="text-2.4">

<p>Statistics should be combined in a boost::fusion::vector (see:
<a href="http://www.boost.org/doc/libs/1_40_0/libs/fusion/doc/html/fusion/container/vector.html">http://www.boost.org/doc/libs/1<sub>40</sub><sub>0</sub>/libs/fusion/doc/html/fusion/container/vector.html</a>)
before being passed to a EA. For instance:
</p>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-constant">boost</span>::<span class="org-constant">fusion</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">stat</span>::<span class="org-type">BestFit</span>&lt;<span class="org-type">phen_t</span>, Params&gt;, <span class="org-constant">stat</span>::<span class="org-type">MeanFit</span>&lt;Params&gt; &gt;  <span class="org-type">stat_t</span>;
</pre>



<p>
(yes, it is a vector of <i>typenames</i>).
You can put in the vector as many statistics types as you
desire.
</p>

</div>

<div id="outline-container-2.4.1" class="outline-4">
<h4 id="sec-2.4.1"><span class="section-number-4">2.4.1</span> BestFit </h4>
<div class="outline-text-4" id="text-2.4.1">

<ul>
<li>
<b>File:</b> <a href="/home/mandor/svn/sferes2/trunk/sferes/stat/best_fit.hpp">sferes/stat/best_fit.hpp</a>
</li>
<li>
<b>Typical typename:</b> 

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-constant">boost</span>::<span class="org-constant">fusion</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">sferes</span>::<span class="org-constant">ea</span>::<span class="org-type">BestFit</span>&lt;<span class="org-type">phen_t</span>, Params&gt; &gt; <span class="org-type">stat_t</span>;
</pre>



<ul>
<li>
<b>Description:</b> 
<ul>
<li>
stores the individual with the highest fitness in _best (getter:
BestFit::best() ). <i>This assumes that the population is sorted</i> and
consequently this statistics stores the first individual of the
population. 
</li>
<li>
This class is designed for single objective optimization and
consequently works using Fitness::_value (and not Fitness::_objs)
</li>
<li>
writes the value of the best fitness in the file
&lt;result_directory&gt;/bestfit.dat ; this file should be easily plotted
with gnuplot or R.

</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2.4.2" class="outline-4">
<h4 id="sec-2.4.2"><span class="section-number-4">2.4.2</span> MeanFit </h4>
<div class="outline-text-4" id="text-2.4.2">

<ul>
<li>
<b>File:</b> <a href="/home/mandor/svn/sferes2/trunk/sferes/stat/mean_fit.hpp">sferes/stat/mean_fit.hpp</a>
</li>
<li>
<b>Typical typename:</b>

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-constant">boost</span>::<span class="org-constant">fusion</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">sferes</span>::<span class="org-constant">ea</span>::<span class="org-type">MeanFit</span>&lt;<span class="org-type">phen_t</span>, Params&gt; &gt; <span class="org-type">stat_t</span>;
</pre>



<ul>
<li>
<b>Description:</b> computes the mean fitness (single objective, based on
Fitness::_value). This class is mainly aimed at providing a simple
example of statistics.
</li>
</ul>
</div>

</div>

<div id="outline-container-2.4.3" class="outline-4">
<h4 id="sec-2.4.3"><span class="section-number-4">2.4.3</span> ParetoFront </h4>
<div class="outline-text-4" id="text-2.4.3">

<ul>
<li>
<b>File:</b> <a href="/home/mandor/svn/sferes2/trunk/sferes/stat/pareto_front.hpp">sferes/stat/pareto_front.hpp</a>
</li>
<li>
<b>Typical typename:</b>

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-constant">boost</span>::<span class="org-constant">fusion</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">sferes</span>::<span class="org-constant">ea</span>::<span class="org-type">ParetoFront</span>&lt;<span class="org-type">phen_t</span>, Params&gt; &gt; <span class="org-type">stat_t</span>;
</pre>



<ul>
<li>
<b>Description:</b> stores the set of non-dominated individuals by copying
the list returned by ea_t::pareto_front(). ParetoFront does not
compute the pareto front; this class assumes that the EA computed
it. This implies that multiobjective EA classes should define the following method:

</li>
</ul>


<pre class="src src-c++"><span class="org-function-name">SFERES_EA</span>(MyEA, Ea)
{
 <span class="org-keyword">public</span>:
  <span class="org-constant">std</span>:<span class="org-type">vector</span>&lt;Indiv&gt; &amp;<span class="org-variable-name">pareto_front</span>() <span class="org-keyword">const</span> { <span class="org-comment-delimiter">/* </span><span class="org-comment">your code */</span> }
};
</pre>



<ul>
<li>
<b>Note:</b> since this statistic can store many individuals, to load a
result file you must give the identifier (the rank in the Pareto
front) to your executable. For instance, assuming that ParetoFront
in the first (0th) statistics in the stat vector, loading the 10th
individual should look like:

</li>
</ul>


<pre class="src src-shell">./my_exp --load gen_100 -s 0 -n 10 -o output
</pre>



</div>

</div>

<div id="outline-container-2.4.4" class="outline-4">
<h4 id="sec-2.4.4"><span class="section-number-4">2.4.4</span> Defining your own statistics </h4>
<div class="outline-text-4" id="text-2.4.4">




<pre class="src src-c++"><span class="org-function-name">SFERES_STAT</span>(MyStat, Stat)
{
  <span class="org-comment-delimiter">// </span><span class="org-comment">examines the population (via the EA) to update the statistics
</span>  <span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">E</span>&gt; <span class="org-type">void</span> <span class="org-variable-name">refresh</span>(<span class="org-keyword">const</span> <span class="org-type">E</span>&amp; <span class="org-variable-name">ea</span>) { <span class="org-comment-delimiter">/* </span><span class="org-comment">your code */</span> }
  <span class="org-comment-delimiter">// </span><span class="org-comment">writes the content of the statistics in the stream; k is the number
</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">of the individual in the statistics (e.g. in a Pareto front, the
</span>  <span class="org-comment-delimiter">// </span><span class="org-comment">statistics contains many individuals)
</span>  <span class="org-type">void</span> <span class="org-variable-name">show</span>(<span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>, <span class="org-type">size_t</span> <span class="org-variable-name">k</span>) <span class="org-keyword">const</span> { <span class="org-comment-delimiter">/* </span><span class="org-comment">your code */</span> }
  <span class="org-comment-delimiter">// </span><span class="org-comment">serializes the statistics using boost::serialization
</span>  <span class="org-keyword">template</span>&lt;<span class="org-keyword">class</span> <span class="org-type">Archive</span>&gt; <span class="org-type">void</span> <span class="org-variable-name">serialize</span>(<span class="org-type">Archive</span> &amp; <span class="org-variable-name">ar</span>, <span class="org-keyword">const</span> <span class="org-type">unsigned</span> <span class="org-type">int</span> <span class="org-variable-name">version</span>)
  { <span class="org-comment-delimiter">/* </span><span class="org-comment">your code */</span> }
}
</pre>




</div>
</div>

</div>

<div id="outline-container-2.5" class="outline-3">
<h3 id="sec-2.5"><span class="section-number-3">2.5</span> Genotypes </h3>
<div class="outline-text-3" id="text-2.5">


</div>

<div id="outline-container-2.5.1" class="outline-4">
<h4 id="sec-2.5.1"><span class="section-number-4">2.5.1</span> BitString </h4>
<div class="outline-text-4" id="text-2.5.1">

<ul>
<li>
<b>File:</b> <a href="/home/mandor/svn/sferes2/trunk/sferes/gen/bit_string.hpp">sferes/gen/bit_string.hpp</a>
</li>
<li>
<b>Unit test:</b> <a href="../../tests/gen/bit_string.hpp">sferes/gen/bit_string.hpp</a>
</li>
<li>
<b>Description:</b> vector of bitstrings which can be used to represent a
vector of integer parameters or a vector of discrete
parameters. Cross-over is a simple one point cross-over (it always
happens). The data can be easily converted to int (in the range
0..2<sup>b</sup>, where b is the number of bits for each bitstring) via
BitString&lt;&gt;::int_data(i) or to float (in the range 0..1) via
BitString&lt;&gt;::data(i)
</li>
<li>
<b>Template parameter:</b> the number of bitstrings
</li>
<li>
<b>Parameters (struct bit_string):</b>
<ul>
<li>
static const size_t nb_bits -&gt; number of bits for each bitstring
</li>
<li>
static const float mutation_rate -&gt; the mutation rate for a
bitstring (the bitstring i is mutated if a random real is belows mutation<sub>rate</sub>)
</li>
<li>
static const float mutation_rate_bit -&gt; the mutation rate <i>for each    bit</i>. In pseudo-code, here is the mutation procedure:

</li>
</ul>
</li>
</ul>


<pre class="src src-c++">foreach(bitstring b <span class="org-type">in</span> <span class="org-variable-name">genotype</span>)
  <span class="org-keyword">if</span> (rand(0, 1) &lt; <span class="org-constant">Params</span>::<span class="org-constant">bit_string</span>::mutation_rate)
    foreach(bit i <span class="org-type">in</span> <span class="org-variable-name">b</span>)
      <span class="org-keyword">if</span> (rand(0, 1) &lt; <span class="org-constant">Params</span>::<span class="org-constant">bit_string</span>::mutation_bit)
        flip(i)   
</pre>



<ul>
<li>
<b>Typical parameters:</b>

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">struct</span> <span class="org-type">Params</span>
{
  <span class="org-keyword">struct</span> <span class="org-type">bit_string</span>
  {
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">size_t</span> <span class="org-variable-name">nb_bits</span> = 8;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">mutate_rate</span> = 0.1f;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">mutate_rate_bit</span> = 0.1f;    
  };
};
</pre>



<ul>
<li>
<b>Typical typename:</b>

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-type">BitString</span>&lt;10, Params&gt; <span class="org-type">gen_t</span>;
</pre>



</div>

</div>

<div id="outline-container-2.5.2" class="outline-4">
<h4 id="sec-2.5.2"><span class="section-number-4">2.5.2</span> EvoFloat </h4>
<div class="outline-text-4" id="text-2.5.2">

<ul>
<li>
<b>File:</b> <a href="/home/mandor/svn/sferes2/trunk/sferes/gen/evo_float.hpp">sferes/gen/evo<sub>float</sub>.hpp</a>
</li>
<li>
<b>Unit test:</b> <a href="/home/mandor/svn/sferes2/trunk/tests/gen/evo_float.cpp">sferes/tests/gen/evo_float.cpp</a>
</li>
<li>
<b>Description:</b> This genotype is a n-sized vector of real (float)
numbers. It is designed for real optimization. 

</li>
<li>
Three mutation types are available:
<ul>
<li>
polynomial:  polynomial mutation, as defined in Deb(200)1, p 124
</li>
<li>
gaussian: adds a gaussian noise to the current value; the variance
is a user-specified parameter
</li>
<li>
uniform: adds a uniform noise to the current value; the range is a
user-specified parameter
</li>
</ul>
</li>
<li>
Two cross-over types are available (you can disable cross-over by
using a cross_rate equals to 0)
<ul>
<li>
recombination: 
<ul>
<li>
a number k is randomly chosen
</li>
<li>
the first child is made of the [0, k[ values of the first
parent and of the [k, n-1[ values of the second parent
</li>
<li>
the second child is made of the [0, k[ values of the second parent
and of the [k, n-1] values of the first parent
</li>
</ul>
</li>
<li>
SBX (simulated binary cross-over, cf Deb (2001), p 113). Warning:
the current implementation is copied from Deb's code and is
slightly different from the original paper.
</li>
</ul>
</li>
<li>
<b>Parameters:</b>
<ul>
<li>
Any variant:
<ul>
<li>
(mutation_t and cross_over_t are defined in the namespace sferes::gen::evo_float)
</li>
<li>
static const mutation_t mutation_type: polynomial, gaussian or uniform;
</li>
<li>
static const cross_over_t cross_over_type -&gt; sbx or recombination;
</li>
<li>
static const float mutation_rate -&gt; the rate of mutation of one
member of the vector
</li>
<li>
static const float cross_rate -&gt; the rate of cross-over (if no
cross-over is applied, parents are copied to children)
</li>
</ul>
</li>
<li>
polynomial mutation:
<ul>
<li>
 static const float eta_m -&gt; &eta;<sub>m</sub> is a parameter which controls
the polynomial distribution. See Deb's paper or book.
</li>
</ul>
</li>
<li>
gaussian mutation:
<ul>
<li>
static const float sigma -&gt; the standard deviation of the gaussian
</li>
</ul>
</li>
<li>
uniform mutation:
<ul>
<li>
static const float max -&gt; maximum change of the current value
</li>
</ul>
</li>
<li>
sbx:
<ul>
<li>
static const float eta_c -&gt; see Deb's paper or book.
</li>
</ul>
</li>
</ul>
</li>
<li>
<b>Typical typename:</b>

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-constant">sferes</span>::<span class="org-constant">gen</span>::<span class="org-type">EvoFloat</span>&lt;10, Params1&gt; <span class="org-type">gen_t</span>;
</pre>



<ul>
<li>
<b>Typical parameters:</b>

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">using</span> <span class="org-keyword">namespace</span> <span class="org-constant">sferes</span>::<span class="org-constant">gen</span>::<span class="org-constant">evo_float</span>;

<span class="org-keyword">struct</span> <span class="org-type">Params1</span>
{
  <span class="org-keyword">struct</span> <span class="org-type">evo_float</span>
  {
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">mutation_rate</span> = 0.1f;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">cross_rate</span> = 0.1f;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">mutation_t</span> <span class="org-variable-name">mutation_type</span> = polynomial;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">cross_over_t</span> <span class="org-variable-name">cross_over_type</span> = sbx;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">eta_m</span> = 15.0f;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">eta_c</span> = 15.0f;
  };
};

<span class="org-keyword">struct</span> <span class="org-type">Params2</span>
{
  <span class="org-keyword">struct</span> <span class="org-type">evo_float</span>
  {
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">mutation_rate</span> = 0.1f;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">cross_rate</span> = 0.1f;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">mutation_t</span> <span class="org-variable-name">mutation_type</span> = gaussian;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">cross_over_t</span> <span class="org-variable-name">cross_over_type</span> = recombination;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">sigma</span> = 0.3f;
  };
};


<span class="org-keyword">struct</span> <span class="org-type">Params3</span>
{
  <span class="org-keyword">struct</span> <span class="org-type">evo_float</span>
  {
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">mutation_rate</span> = 0.1f;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">cross_rate</span> = 0.1f;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">mutation_t</span> <span class="org-variable-name">mutation_type</span> = uniform;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">cross_over_t</span> <span class="org-variable-name">cross_over_type</span> = sbx;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">max</span> = 0.3f;
    <span class="org-keyword">static</span> <span class="org-keyword">const</span> <span class="org-type">float</span> <span class="org-variable-name">eta_c</span> = 15.0f;
  };
};

</pre>



</div>

</div>

<div id="outline-container-2.5.3" class="outline-4">
<h4 id="sec-2.5.3"><span class="section-number-4">2.5.3</span> Defining your own genotype </h4>
<div class="outline-text-4" id="text-2.5.3">




<pre class="src src-c++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sferes/stc/stc.hpp&gt;</span>
<span class="org-keyword">namespace</span> <span class="org-constant">sferes</span>
{
  <span class="org-keyword">namespace</span> <span class="org-constant">gen</span>
  {  
    <span class="org-function-name">SFERES_CLASS</span>(MyGenotype)
    {
    <span class="org-keyword">public</span>:
      <span class="org-comment-delimiter">// </span><span class="org-comment">generates a random genotype
</span>      <span class="org-type">void</span> <span class="org-variable-name">random</span>()
      {
      <span class="org-comment-delimiter">// </span><span class="org-comment">your code
</span>      }
      <span class="org-comment-delimiter">// </span><span class="org-comment">mutates an individual
</span>      <span class="org-type">void</span> <span class="org-variable-name">mutate</span>() 
      { 
      <span class="org-comment-delimiter">// </span><span class="org-comment">your code to mutate (you have to handle your own mutation_rate)
</span>      }
      <span class="org-comment-delimiter">// </span><span class="org-comment">WARNING: the arguments of this method are of the same type
</span>      <span class="org-comment-delimiter">// </span><span class="org-comment">than your genotype
</span>      <span class="org-type">void</span> <span class="org-variable-name">cross</span>(<span class="org-keyword">const</span> <span class="org-type">MyGenotype</span>&amp; <span class="org-variable-name">o</span>, <span class="org-type">MyGenotype</span>&amp; <span class="org-variable-name">c1</span>, <span class="org-type">MyGenotype</span>&amp; <span class="org-variable-name">c2</span>)
      {
      <span class="org-comment-delimiter">// </span><span class="org-comment">if you don't know what to do, simply use:
</span>      <span class="org-keyword">if</span> (<span class="org-constant">misc</span>::flip_coin())
        {
          c1 = *<span class="org-keyword">this</span>;
          c2 = o;
          }
        <span class="org-keyword">else</span>
          {
            c2 = *<span class="org-keyword">this</span>;
            c1 = o;
          }   
      }
    <span class="org-keyword">protected</span>:
      <span class="org-comment-delimiter">// </span><span class="org-comment">your data here (your genotype)
</span>    };
  }
}
</pre>



</div>
</div>

</div>

<div id="outline-container-2.6" class="outline-3">
<h3 id="sec-2.6"><span class="section-number-3">2.6</span> Phenotypes (Individuals) </h3>
<div class="outline-text-3" id="text-2.6">

<p>Phenotypes are the expression of the genotypes: it is often useful to
develop a genotype into a structure which is easier to evaluate. For
instance, a neural network can be encoded with a compact encoding
(genotype, e.g. a modular encoding which can repeat the same module several
times), then developped into a standard neural network (phenotype).
</p>
<p>
Phenotypes are also the bridge between the fitness function and the
genotype. In sferes2, a phenotype is the composition of a fit_t and
a gen_t.
</p>

</div>

<div id="outline-container-2.6.1" class="outline-4">
<h4 id="sec-2.6.1"><span class="section-number-4">2.6.1</span> Indiv </h4>
<div class="outline-text-4" id="text-2.6.1">

<ul>
<li>
<b>File:</b> <a href="/home/mandor/svn/sferes2/trunk/sferes/indiv.hpp">sferes/phen/indiv.hpp</a>
</li>
<li>
<b>Description:</b> The abstract base class for phenotypes.
</li>
<li>
<b>Main public methods:</b>

</li>
</ul>


<pre class="src src-c++"><span class="org-comment-delimiter">// </span><span class="org-comment">returns the fitness
</span>Fit&amp; fit();
<span class="org-keyword">const</span> <span class="org-type">Fit</span>&amp; <span class="org-function-name">fit</span>() <span class="org-keyword">const</span>;
<span class="org-comment-delimiter">// </span><span class="org-comment">returns the genotype
</span><span class="org-type">Gen</span>&amp; <span class="org-function-name">gen</span>()  { <span class="org-keyword">return</span> _gen; }
<span class="org-keyword">const</span> <span class="org-type">Gen</span>&amp; <span class="org-function-name">gen</span>() <span class="org-keyword">const</span> { <span class="org-keyword">return</span> _gen; }
<span class="org-comment-delimiter">// </span><span class="org-comment">develops the genotype, called by the evalutar before evaluating
</span><span class="org-comment-delimiter">// </span><span class="org-comment">the individual
</span><span class="org-type">void</span> <span class="org-function-name">develop</span>();
<span class="org-comment-delimiter">// </span><span class="org-comment">you can also override the following methods (although in most
</span><span class="org-comment-delimiter">// </span><span class="org-comment">cases, you should override their equivalent in the genotype)
</span><span class="org-type">void</span> <span class="org-function-name">mutate</span>();
<span class="org-type">void</span> <span class="org-function-name">random</span>();
<span class="org-type">void</span> <span class="org-function-name">cross</span>(<span class="org-keyword">const</span> <span class="org-constant">boost</span>::<span class="org-type">shared_ptr</span>&lt;Exact&gt; <span class="org-variable-name">i2</span>, 
         <span class="org-constant">boost</span>::<span class="org-type">shared_ptr</span>&lt;Exact&gt;&amp; <span class="org-variable-name">o1</span>, 
         <span class="org-constant">boost</span>::<span class="org-type">shared_ptr</span>&lt;Exact&gt;&amp; <span class="org-variable-name">o2</span>);
<span class="org-comment-delimiter">// </span><span class="org-comment">this method is not implemented in Indiv but it must be in all the
</span><span class="org-comment-delimiter">// </span><span class="org-comment">concrete genotypes. It should describe this particular individual
</span><span class="org-comment-delimiter">// </span><span class="org-comment">in the stream os (see the Parameter source code for an example)
</span><span class="org-type">void</span> <span class="org-function-name">show</span>(<span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>) <span class="org-keyword">const</span>
</pre>



<ul>
<li>
<b>Defined types:</b>
<ul>
<li>
Fit -&gt; the fitness functor
</li>
<li>
Gen -&gt; genotype
</li>
</ul>
</li>
</ul>
</div>

</div>

<div id="outline-container-2.6.2" class="outline-4">
<h4 id="sec-2.6.2"><span class="section-number-4">2.6.2</span> Parameters </h4>
<div class="outline-text-4" id="text-2.6.2">

<ul>
<li>
<b>File:</b> <a href="/home/mandor/svn/sferes2/trunk/sferes/phen/parameters.hpp">sferes/gen/parameters.hpp</a>
</li>
<li>
<b>Unit test:</b> <a href="/home/mandor/svn/sferes2/trunk/tests/phen/parameters.cpp">sferes/tests/phen/parameters.cpp</a>
</li>
<li>
<b>Description:</b> This phenotype transforms a list of parameters in
[0, 1[ (typically a gen::Bitstring or a gen::EvoFloat) to a list of
parameter in [min, max[. The genotype class must define a method:

</li>
</ul>


<pre class="src src-c++">cont <span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-type">float</span>&gt;&amp; <span class="org-function-name">data</span>() <span class="org-keyword">const</span> ();
</pre>



<ul>
<li>
<b>Typical typename:</b>

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-constant">eval</span>::<span class="org-type">Parameters</span>&lt;<span class="org-type">gen_t</span>, <span class="org-type">fit_t</span>, Params&gt; <span class="org-type">phen_t</span>;
</pre>




</div>

</div>

<div id="outline-container-2.6.3" class="outline-4">
<h4 id="sec-2.6.3"><span class="section-number-4">2.6.3</span> Defining your own phenotype </h4>
<div class="outline-text-4" id="text-2.6.3">




<pre class="src src-c++"><span class="org-preprocessor">#include</span> <span class="org-string">&lt;sferes/phen/indiv.hpp&gt;</span>
<span class="org-keyword">namespace</span> <span class="org-constant">sferes</span>
{
  <span class="org-keyword">namespace</span> <span class="org-constant">phen</span>
  {
    <span class="org-function-name">SFERES_INDIV</span>(MyPhenotype, Indiv)
    {
    <span class="org-keyword">public</span>:
      <span class="org-comment-delimiter">// </span><span class="org-comment">constructor
</span>      <span class="org-variable-name">MyPhenotype</span>() { <span class="org-comment-delimiter">/* </span><span class="org-comment">your code */</span> }
      <span class="org-comment-delimiter">// </span><span class="org-comment">develop the genotype to whatever you want
</span>      <span class="org-type">void</span> <span class="org-variable-name">develop</span>(){ <span class="org-comment-delimiter">/* </span><span class="org-comment">your code */</span> }
      <span class="org-comment-delimiter">// </span><span class="org-comment">describe this individual
</span>      <span class="org-type">void</span> <span class="org-variable-name">show</span>(<span class="org-constant">std</span>::<span class="org-type">ostream</span>&amp; <span class="org-variable-name">os</span>) <span class="org-keyword">const</span> { <span class="org-comment-delimiter">/* </span><span class="org-comment">your code */</span> }
    <span class="org-keyword">protected</span>:
      <span class="org-comment-delimiter">// </span><span class="org-comment">your data
</span>    };
  }
}
</pre>





</div>
</div>

</div>

<div id="outline-container-2.7" class="outline-3">
<h3 id="sec-2.7"><span class="section-number-3">2.7</span> Evaluators </h3>
<div class="outline-text-3" id="text-2.7">

<p>Evaluators are in charge of evalutating a vector of individuals
(i.e. running phen_t::fit::eval() for each individual).
</p>
</div>

<div id="outline-container-2.7.1" class="outline-4">
<h4 id="sec-2.7.1"><span class="section-number-4">2.7.1</span> Eval </h4>
<div class="outline-text-4" id="text-2.7.1">

<ul>
<li>
<b>File:</b> <a href="/home/mandor/svn/sferes2/trunk/sferes/eval/eval.hpp">sferes/eval/eval.hpp</a>
</li>
<li>
A basic evaluator (no multiprocessing, no MPI, etc.), i.e. a basic
loop.
</li>
<li>
<b>Typical typename:</b>

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-constant">eval</span>::<span class="org-type">Eval</span>&lt;Params&gt; <span class="org-type">eval_t</span>;
</pre>




</div>

</div>

<div id="outline-container-2.7.2" class="outline-4">
<h4 id="sec-2.7.2"><span class="section-number-4">2.7.2</span> Parallel </h4>
<div class="outline-text-4" id="text-2.7.2">

<ul>
<li>
<b>File:</b> <a href="/home/mandor/svn/sferes2/trunk/sferes/eval/parallel.hpp">sferes/eval/parallel.hpp</a>
</li>
<li>
<b>Description:</b> A SMP/multicore evaluator based on TBB
(<a href="http://www.threadingbuildingblocks.org/">http://www.threadingbuildingblocks.org/</a>). <b>Your fitness should be   thread-safe!</b>
</li>
<li>
<b>Typical typename:</b>

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-constant">eval</span>::<span class="org-type">Parallel</span>&lt;Params&gt; <span class="org-type">eval_t</span>;
</pre>




</div>

</div>

<div id="outline-container-2.7.3" class="outline-4">
<h4 id="sec-2.7.3"><span class="section-number-4">2.7.3</span> Mpi </h4>
<div class="outline-text-4" id="text-2.7.3">

<ul>
<li>
<b>File:</b> <a href="sferes/eval/mpi.hpp">sferes/eval/mpi.hpp</a>
</li>
<li>
<b>Description:</b> A MPI evaluator based on boost::mpi. It works on clusters (we use it
on a JS22 cluster with IBM MPI).
</li>
<li>
<b>Typical typename:</b>

</li>
</ul>


<pre class="src src-c++"><span class="org-keyword">typedef</span> <span class="org-constant">eval</span>::<span class="org-type">Mpi</span>&lt;Params&gt; <span class="org-type">eval_t</span>;
</pre>



</div>

</div>

<div id="outline-container-2.7.4" class="outline-4">
<h4 id="sec-2.7.4"><span class="section-number-4">2.7.4</span> Defining your own evaluator </h4>
<div class="outline-text-4" id="text-2.7.4">

<p>The only required method is eval. It should call phen_t::develop()
then phen_t::fit::eval() for each individual.
</p>


<pre class="src src-c++"><span class="org-keyword">namespace</span> <span class="org-constant">sferes</span>
{
  <span class="org-keyword">namespace</span> <span class="org-constant">eval</span>
  {
    <span class="org-function-name">SFERES_EVAL</span>(Eval)
    {
    <span class="org-keyword">public</span>:
      <span class="org-keyword">template</span>&lt;<span class="org-keyword">typename</span> <span class="org-type">Phen</span>&gt;
        <span class="org-type">void</span> <span class="org-variable-name">eval</span>(<span class="org-constant">std</span>::<span class="org-type">vector</span>&lt;<span class="org-constant">boost</span>::<span class="org-type">shared_ptr</span>&lt;<span class="org-type">Phen</span>&gt; &gt;&amp; <span class="org-variable-name">pop</span>, <span class="org-type">size_t</span> <span class="org-variable-name">begin</span>, <span class="org-type">size_t</span> <span class="org-variable-name">end</span>)
      {
        <span class="org-keyword">for</span> (<span class="org-type">size_t</span> <span class="org-variable-name">i</span> = begin; i &lt; end; ++i)
          {
            pop[i]-&gt;develop();
            pop[i]-&gt;fit().eval(*pop[i]);
          }
      }
    <span class="org-keyword">protected</span>:
    };
  }
}
</pre>




</div>
</div>

</div>

<div id="outline-container-2.8" class="outline-3">
<h3 id="sec-2.8"><span class="section-number-3">2.8</span> Modifiers </h3>
<div class="outline-text-3" id="text-2.8">

<p>Modifiers are run once all the individuals have been evaluated but
before any sorting. They are designed to allow to modify the fitness
values to implement niching strategies, diversity preservation
mechanisms, etc.
</p>
<p>
The only predefined modifier available in sferes2 is
modif::Dummy, which does nothing.
</p>
</div>

<div id="outline-container-2.8.1" class="outline-4">
<h4 id="sec-2.8.1"><span class="section-number-4">2.8.1</span> Dummy </h4>
<div class="outline-text-4" id="text-2.8.1">

<ul>
<li>
<b>File:</b> <a href="/home/mandor/svn/sferes2/trunk/sferes/modif/dummy.hpp">sferes/modif/dummy.hpp</a>
</li>
<li>
<b>Description:</b> basic modifier which does nothing.
</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-2.9" class="outline-3">
<h3 id="sec-2.9"><span class="section-number-3">2.9</span> Misc </h3>
<div class="outline-text-3" id="text-2.9">

<p>The misc namespace contains useful small functions for:
</p><ul>
<li>
system access (e.g getpid())
</li>
<li>
random number generation

</li>
</ul>
</div>
</div>

</div>

<div id="outline-container-3" class="outline-2">
<h2 id="sec-3"><span class="section-number-2">3</span> Modules </h2>
<div class="outline-text-2" id="text-3">


</div>

<div id="outline-container-3.1" class="outline-3">
<h3 id="sec-3.1"><span class="section-number-3">3.1</span> NN </h3>
<div class="outline-text-3" id="text-3.1">

</div>

</div>

<div id="outline-container-3.2" class="outline-3">
<h3 id="sec-3.2"><span class="section-number-3">3.2</span> Fastsim </h3>
<div class="outline-text-3" id="text-3.2">

</div>

</div>

<div id="outline-container-3.3" class="outline-3">
<h3 id="sec-3.3"><span class="section-number-3">3.3</span> Python </h3>
<div class="outline-text-3" id="text-3.3">

<p><a href="sferes2.html">{back to main page}</a>
</p>
</div>
</div>

</div>

<div id="outline-container-4" class="outline-2">
<h2 id="sec-4"><span class="section-number-2">4</span> Writing modules </h2>
<div class="outline-text-2" id="text-4">

</div>
</div>
<div id="postamble">
<p class="author"> Author: Jean-Baptiste Mouret
<a href="mailto:mouret@isir.fr">&lt;mouret@isir.fr&gt;</a>
</p>
<p class="date"> Date: 2010-01-31 20:59:49 CET</p>
<p class="creator">HTML generated by org-mode 6.28e in emacs 23</p>
</div>
</div>
</body>
</html>
