<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE book PUBLIC "-//Boost//DTD BoostBook XML V1.0//EN" "http://www.boost.org/tools/boostbook/dtd/boostbook.dtd">
<book id="documentation" last-revision="$Date: 2012/07/24 12:39:11 $" xmlns:xi="http://www.w3.org/2001/XInclude">
  <title>Documentation 1.0</title>
  <bookinfo>
    <copyright>
      <year>2011</year> <holder></holder>
    </copyright>
    <legalnotice id="documentation.legal">
      <para>
        CeCiLL
      </para>
    </legalnotice>
  </bookinfo>
  <section id="documentation.sferes2">
    <title><link linkend="documentation.sferes2">Sferes 2</link></title>
    <section id="documentation.sferes2.introduction">
      <title><link linkend="documentation.sferes2.introduction">Introduction</link></title>
      <para>
        Sferes2 is a <emphasis>framework</emphasis> for evolutionary computation
        (EC) experiments and especially for evolutionary robotics (ER). Its main
        goal is to help researchers in EC and ER to efficiently try new ideas. Sferes2
        has been inspired by sferes <ulink url="http://sferes.lip6.fr">http://sferes.lip6.fr</ulink>,
        another (older and no more maintained) framework for ER.
      </para>
      <para>
        Sferes2 allows to design efficient programs on modern (multicore) computers:
        our experiments typically require more than 24 hours of computation; in this
        situation it can be profitable to trade some complexity of implementation
        for some hours of computation. Nevertheless, we try to keep the framework
        as simple as possible. More specifically, the following choices were made
        in the initial design:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            use of modern c++ techniques (template-based programming) to employ object-oriented
            programming without the cost of virtual functions;
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            use of Intel TBB to take full advantages of multicore and SMP systems;
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            use of boost libraries when it's useful (shared_ptr, serialization, filesystem,
            test,...);
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            use of MPI to distribute the computational cost on clusters;
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            a full set of unit tests;
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            no configuration file: a fully optimized executable is built for each
            particular experiment.
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        Appart from this documentation, information about Sferes 2 can be found in
        <ulink url="http://www.isir.upmc.fr/files/2010ACTI1524.pdf">Sferes_v2: Evolvin'
        in the Multi-Core World</ulink>. If you use Sferes 2 in your work, please
        cite <ulink url="http://www.isir.upmc.fr/pages/get_bib.php?id=1524">the previous
        publication</ulink>.
      </para>
      <para>
        The source code of many experiments using sferes is available on the <ulink
        url="htpp://pages.isir.upmc.fr/evorob_db">evorob_db website</ulink>
      </para>
      <para>
        This documentation assumes that the reader is reasonably familiar with evolutionary
        algorithms. For references you can check the following books about evolutionary
        computation:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            Deb, K. (2001). Multi-Objective Optimization Using Evolutionary Algorithms.
            <emphasis>Wiley</emphasis>.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            De Jong, K. A. (2002). Evolutionary Computation. <emphasis>The MIT Press</emphasis>.
          </simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section id="documentation.sferes2.main_features">
      <title><link linkend="documentation.sferes2.main_features">Main features</link></title>
      <para>
        Sferes2 currently includes the following EA and toolboxes (this is a non-exhaustive
        list which contains only the most stable modules):
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            EA
            <itemizedlist>
              <listitem>
                <simpara>
                  a rank-based single-objective EA
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  CMAES (Covariance Matrix Adaptation Evolution Strategie)
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  NSGA-II (multiobjective EA)
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  Epsilon-MOEA (multiobjective EA)
                </simpara>
              </listitem>
            </itemizedlist>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Genotypes / Phenotypes:
            <itemizedlist>
              <listitem>
                <simpara>
                  Evolution of bit strings
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  Evolution of real parameters using different operators (SBX, gaussian,
                  etc)
                </simpara>
              </listitem>
            </itemizedlist>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Simulators
            <itemizedlist>
              <listitem>
                <simpara>
                  (optional) mobile robot (Khepera-like)
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  (optional) cartpole (single and double)
                </simpara>
              </listitem>
            </itemizedlist>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Other
            <itemizedlist>
              <listitem>
                <simpara>
                  (optional) evolution of neural-networks
                </simpara>
              </listitem>
            </itemizedlist>
          </simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section id="documentation.sferes2.authors">
      <title><link linkend="documentation.sferes2.authors">Authors</link></title>
      <itemizedlist>
        <listitem>
          <simpara>
            Jean-Baptiste Mouret <ulink url="mailto:mouret@isir.fr">mouret@isir.fr</ulink>:
            main author and maintainer
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Stephane Doncieux
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Paul Tonelli<ulink url="mailto:paul@tonel.li">paul@tonel.li</ulink> :
            Documentation maintainer
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            Many members of <ulink url="http://www.isir.fr">ISIR</ulink>
          </simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section id="documentation.sferes2.where_to_go_next_">
      <title><link linkend="documentation.sferes2.where_to_go_next_">Where to go
      next?</link></title>
      <para>
        <link linkend="documentation.download">Download</link> Downloading sferes2
      </para>
      <para>
        <link linkend="documentation.compilation">Compilation</link> How to compile
        sferes2 on your system
      </para>
      <para>
        <link linkend="documentation.tutorial">Tutorial/Example</link> A tutorial/example
        with explanation about the general structure of sferes2 experiment files,
        the example file is generated automatically in the next tutorials.
      </para>
      <para>
        <link linkend="documentation.tutorial_neuro">Neurobiology Tutorial I</link>
        A tutorial to create an experiment using the neural network module of sferes2,
        this enables you to create a neural network and evolve its weights and parameters.
      </para>
      <para>
        <link linkend="documentation.tutorial_topo">Neurobiology Tutorial II</link>
        A tutorial to evolve the topology of a network in sferes2
      </para>
      <para>
        <link linkend="documentation.tutorial_evoneuro">Neurobiology Tutorial III</link>
        A tutorial to evolve a network of maps using the EvoNeuro module from sferes
        II.
      </para>
      <para>
        <link linkend="documentation.reference">Reference</link> A reference manual
        / guide to the source code
      </para>
    </section>
    <section id="documentation.sferes2.specific_sections_for_isir_members">
      <title><link linkend="documentation.sferes2.specific_sections_for_isir_members">Specific
      sections for ISIR members</link></title>
      <para>
        <link linkend="documentation.torque">Torque Introduction</link> A reference
        to launching experiments on the ISIR cluster
      </para>
    </section>
  </section>
  <section id="documentation.download">
    <title><link linkend="documentation.download">Download and unzip</link></title>
    <section id="documentation.download.if_you_are_not_a_member_of_isir">
      <title><link linkend="documentation.download.if_you_are_not_a_member_of_isir">If
      you are not a member of ISIR</link></title>
      <section id="documentation.download.if_you_are_not_a_member_of_isir.download_the_last_version">
        <title><link linkend="documentation.download.if_you_are_not_a_member_of_isir.download_the_last_version">Download
        the last version</link></title>
        <para>
          The last version of sferes2 is available <ulink url="http://chronos.isir.upmc.fr/~sferes2/bin/sferes2.latest.tar.bz2">here</ulink>.
          The archive is updated daily and contains the main sferes code as well
          as core modules and a few sample experiments.
        </para>
      </section>
      <section id="documentation.download.if_you_are_not_a_member_of_isir.unzip_the_archive">
        <title><link linkend="documentation.download.if_you_are_not_a_member_of_isir.unzip_the_archive">Unzip
        the archive</link></title>
        <para>
          To unzip the archive type the following command in the folder in which
          you downloaded the archive:
        </para>
        <para>
<programlisting>tar -xvjf sferes2.latest.tar.bz2</programlisting>
        </para>
      </section>
      <section id="documentation.download.if_you_are_not_a_member_of_isir.go_to_sferes_root">
        <title><link linkend="documentation.download.if_you_are_not_a_member_of_isir.go_to_sferes_root">Go
        to sferes root</link></title>
        <para>
          You can now change the directory to the root folder of sferes by typing
          the following command (replace ${VERSION} by your version number):
<programlisting>cd sferes2-${VERSION}</programlisting>
        </para>
      </section>
    </section>
    <section id="documentation.download.if_you_are_a_member_of_isir">
      <title><link linkend="documentation.download.if_you_are_a_member_of_isir">If
      you are a member of ISIR</link></title>
      <section id="documentation.download.if_you_are_a_member_of_isir.checkout_the_svn_version">
        <title><link linkend="documentation.download.if_you_are_a_member_of_isir.checkout_the_svn_version">Checkout
        the svn version</link></title>
        <para>
          If you are a member of ISIR, you should checkout the last version of sferes2
          from the svn repository:
        </para>
        <para>
<programlisting>svn co https://hotline.isir.upmc.fr/svn/sferes2</programlisting>
        </para>
      </section>
      <section id="documentation.download.if_you_are_a_member_of_isir.checkout_the_svn_of_experiments_and_modules">
        <title><link linkend="documentation.download.if_you_are_a_member_of_isir.checkout_the_svn_of_experiments_and_modules">Checkout
        the svn of experiments and modules</link></title>
        <para>
          you should then checkout the svn containing the other isir experiments:
        </para>
        <para>
<programlisting>svn co https://hotline.isir.upmc.fr/svn/er/src/sferes/exp</programlisting>
        </para>
        <para>
          as well as the modules:
        </para>
        <para>
<programlisting>svn co https://hotline.isir.upmc.fr/svn/er/src/sferes/modules</programlisting>
        </para>
      </section>
      <section id="documentation.download.if_you_are_a_member_of_isir.go_to_sferes_root_and_add_additionnal_experiments">
        <title><link linkend="documentation.download.if_you_are_a_member_of_isir.go_to_sferes_root_and_add_additionnal_experiments">Go
        to sferes root and add additionnal experiments</link></title>
        <para>
          You can now change the directory to the root folder of sferes by typing
          the following command :
<programlisting>cd sferes2/trunk</programlisting>
        </para>
        <para>
          and add the additionnal modules and experiments to the path:
        </para>
        <para>
<programlisting>cd modules
ln -sf ../../../modules/* .
cd ../exp
ln -sf ../../../exp/* .
cd ..
</programlisting>
        </para>
        <para>
          this should create the correct shortcuts to link the experiments from the
          svn in Sferes 2.
        </para>
      </section>
    </section>
  </section>
  <section id="documentation.torque">
    <title><link linkend="documentation.torque">Launching experiments using Torque</link></title>
    <para>
      This short tutorial is intended for isir members who are working on the <ulink
      url="http://intranet.isir.upmc.fr/index.php?page=cluster-isir">ISIR cluster</ulink>.
      It explains how to automatically launch a batch of experiments on the cluster
      nodes
    </para>
    <section id="documentation.torque.script_files">
      <title><link linkend="documentation.torque.script_files">Script Files</link></title>
      <para>
        The torque system used on the cluster can be launched using the <ulink url="http://www.hpc.dtu.dk/GridEngine/man/qsub.html">qsub</ulink>
        command. However, waf, used to compile sferes was scripted to accept experiment
        files.
      </para>
      <para>
        The files used for experiments are in json format and should have the .json
        extension for easier maintenance.
      </para>
      <para>
        each file has the following structure
      </para>
      <para>
<programlisting><phrase role="special">{</phrase>
   <phrase role="string">&quot;email&quot;</phrase> <phrase role="special">:</phrase> <phrase role="string">&quot;yourname@youraddress.com&quot;</phrase><phrase role="special">,</phrase>
   <phrase role="string">&quot;wall_time&quot;</phrase> <phrase role="special">:</phrase> <phrase role="string">&quot;00:59:59&quot;</phrase><phrase role="special">,</phrase>
   <phrase role="string">&quot;nb_runs&quot;</phrase><phrase role="special">:</phrase> <phrase role="number">4</phrase><phrase role="special">,</phrase>
   <phrase role="string">&quot;bin_dir&quot;</phrase><phrase role="special">:</phrase> <phrase role="string">&quot;/${path_to_binaries}/&quot;</phrase><phrase role="special">,</phrase>
   <phrase role="string">&quot;res_dir&quot;</phrase><phrase role="special">:</phrase> <phrase role="string">&quot;/${path_to_results_folder}&quot;</phrase><phrase role="special">,</phrase>
   <phrase role="string">&quot;exps&quot;</phrase> <phrase role="special">:</phrase> <phrase role="special">[</phrase><phrase role="string">&quot;${binary_name_2}&quot;</phrase><phrase role="special">,</phrase><phrase role="string">&quot;${binary_name_2}&quot;</phrase><phrase role="special">]</phrase>
<phrase role="special">}</phrase>
</programlisting>
      </para>
      <para>
        The <emphasis role="bold">email</emphasis> field is used by the system to
        report each job status after it ends.
      </para>
      <para>
        The <emphasis role="bold">wall_time</emphasis> field defines the maximum
        allowed time for each job. If your experiment has not exited at the end of
        the time, it will be killed by the server. The wall time is used by torque
        to define the number of parrallel nodes allocated on the cluster :
      </para>
      <table frame="all" id="documentation.torque.script_files.id">
        <title>Wall time and parrallel execution</title>
        <tgroup cols="2">
          <thead>
            <row>
              <entry>
                <para>
                  Wall_time
                </para>
              </entry>
              <entry>
                <para>
                  cluster nodes used
                </para>
              </entry>
            </row>
          </thead>
          <tbody>
            <row>
              <entry>
                <para>
                  &lt;01:00:00
                </para>
              </entry>
              <entry>
                <para>
                  8
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  &lt;12:00:00
                </para>
              </entry>
              <entry>
                <para>
                  4
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  &lt;24:00:00
                </para>
              </entry>
              <entry>
                <para>
                  2
                </para>
              </entry>
            </row>
            <row>
              <entry>
                <para>
                  &gt;23:59:59
                </para>
              </entry>
              <entry>
                <para>
                  1
                </para>
              </entry>
            </row>
          </tbody>
        </tgroup>
      </table>
      <para>
        The <emphasis role="bold">nb_runs</emphasis> defines the number of jobs which
        should be created.
      </para>
      <para>
        The <emphasis role="bold">bin_dir</emphasis> sets the path to find the binaries
        to execute, you must put a complete path to your executables (avoid ~ as
        the user who will execute the program is not your regular user).
      </para>
      <para>
        The <emphasis role="bold">res_dir</emphasis> sets the path to put the results
      </para>
      <para>
        The <emphasis role="bold">exps</emphasis> sets the name of the binaries to
        execute. If you have more than one binary, the file will creat nb_runs jobs
        for each binary.
      </para>
    </section>
    <section id="documentation.torque.commands">
      <title><link linkend="documentation.torque.commands">Commands</link></title>
      <para>
        After creating ${your_exp}.json file, you can launch it on the cluster using
        the following syntax:
      </para>
      <para>
<programlisting>./waf --qsub ${path_to_your_json}/${your_json_file}.json
</programlisting>
      </para>
      <para>
        This will create all the required jobs in the queue.
      </para>
      <para>
        To check if the current queue, you can use the <ulink url="http://www.hpc.dtu.dk/GridEngine/man/qstat.html">qstat</ulink>
        command. Its output should look like this:
      </para>
      <para>
<programlisting>Job id                    Name             User            Time Use S Queue
------------------------- ---------------- --------------- -------- - -----
83356.cluster             ...e10_swap2_nov username2         73:50:34 R q1jour
83357.cluster             ...e10_swap5_nov username2                0 Q q1jour
83358.cluster             ...e10_swap5_nov username2                0 Q q1jour
83359.cluster             ...odulation_nov username1         74:34:31 R q1jour
83360.cluster             ...odulation_nov username1                0 Q q1jour
83361.cluster             ...odulation_nov username1                0 Q q1jour

</programlisting>
      </para>
      <para>
        If you want to remove jobs from the queue (you can only remove [`your] jobs
        from the queue), you can use the <ulink url="http://www.hpc.dtu.dk/GridEngine/man/qdel.html">qdel</ulink>
        with the following syntax
      </para>
      <para>
<programlisting>qdel ${job_id}
</programlisting>
      </para>
      <para>
        Usually, your experiment ids will be grouped, so you can delete multiple
        jobs using the following syntax:
      </para>
      <para>
<programlisting>for i in `seq ${start_id} ${end_id}`;do qdel $i;done
</programlisting>
      </para>
    </section>
    <section id="documentation.torque.result_files">
      <title><link linkend="documentation.torque.result_files">Result Files</link></title>
      <para>
        The result from your experiments will be put in the res_dir folder. For each
        experiment, a folder with its name will be created containing one subdirectory
        for each job in the experiment named job_1, job_2... Each of these folder
        will contain:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            the usual generated files depending on your experiment
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            a ${your_exp_name}.e??? containing the stderr output if relevant
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            an stdout file containing the console output from the experiment
          </simpara>
        </listitem>
      </itemizedlist>
    </section>
  </section>
  <section id="documentation.compilation">
    <title><link linkend="documentation.compilation">Compilation</link></title>
    <section id="documentation.compilation.dependencies">
      <title><link linkend="documentation.compilation.dependencies">Dependencies</link></title>
      <para>
        We list here the Ubuntu package names:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            [required] libboost-dev &gt;= 1.35 (including test, serialization, graph,
            program_options, filesystem); see <ulink url="http://www.boost.org">http://www.boost.org</ulink>;
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [required] libboost-test-dev &gt;= 1.35
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [required] libboost-filesystem-dev &gt;= 1.35
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [required] libboost-program-options-dev &gt;= 1.35
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [required] libboost-graph-parallel-dev &gt;= 1.35
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [required] python &gt;= 2.4;
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [required] g++ &gt;= 4.2 (this should work with icc too);
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [optional but highly recommended] libtbb-dev; see <ulink url="http://www.threadingbuildingblocks.org/">http://www.threadingbuildingblocks.org/</ulink>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [optional but recommended] libeigen2-dev &gt;= 2.06; see <ulink url="http://eigen.tuxfamily.org/">http://eigen.tuxfamily.org/</ulink>
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [optional but recommended] python-simplejson;
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [optional] libsdl1.2-dev , useful for visualisation of experiments
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [optional] libboost-mpi-dev , if you need the optional MPI support (Warning:
            the Ubuntu packages of boost are not compiled with MPI support; you will
            have to compile boost yourself to use MPI).
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [optional] OpenMPI or another MPI implementation (tested with IBM MPI
            and OpenMPI)
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            [optional] libgoogle-perftools-dev.
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        if you are under debian, the complete command line to type is :
      </para>
      <para>
<programlisting>sudo apt-get install libboost-dev libboost-test-dev libboost-filesystem-dev libboost-program-options-dev libboost-graph-parallel-dev python g++ libtbb-dev libeigen2-dev python-simplejson libgoogle-perftools-dev</programlisting>
      </para>
    </section>
    <section id="documentation.compilation.compilation">
      <title><link linkend="documentation.compilation.compilation">Compilation</link></title>
      <section id="documentation.compilation.compilation.simple_compilation">
        <title><link linkend="documentation.compilation.compilation.simple_compilation">Simple
        compilation</link></title>
        <para>
          The next step is to configure sferes prior to compiling it. We will disable
          mpi as its use is complex.
        </para>
        <para>
<programlisting>./waf configure --no-mpi</programlisting>
        </para>
        <para>
          If you have followed this tutorial, the output should look like this:
        </para>
        <para>
<programlisting>Check for program g++ or c++             : /usr/bin/g++
Check for program cpp                    : /usr/bin/cpp
Check for program ar                     : /usr/bin/ar
Check for program ranlib                 : /usr/bin/ranlib
Checking for g++                         : ok
boost headers                            : Version 1_46_1 (/usr/include)
library boost_serialization              : ok
library boost_filesystem                 : ok
library boost_system                     : ok
library boost_unit_test_framework        : ok
library boost_program_options            : ok
library boost_graph                      : not found
library boost_mpi                        : not found
library boost_python                     : not found
library boost_thread                     : not found
Checking for header tbb/parallel_for.h   : ok /usr/include
Checking for library libtbb              : ok /usr/lib
Checking for header tbb/parallel_for.h   : ok /usr/include
Checking for library libtbb              : ok /usr/lib
Checking for header mpi.h                : not found
Checking for SDL (optional)              : ok
Checking for header Eigen/Core           : ok /usr/include/eigen2
Check for program ode-config             : not found
Checking for ODE (optional)              : not found
Checking for GSL (optional)              : not found
</programlisting>
        </para>
        <para>
          Assuming that everything has been properly installed you should be able
          to compile sferes2 by typing:
<programlisting>./waf build</programlisting>
        </para>
        <para>
          which should produce the output
        </para>
        <para>
<programlisting>'build' finished successfully (1m18.284s)</programlisting>
        </para>
        <para>
          You should then run the unit tests:
        </para>
        <para>
<programlisting>./waf check</programlisting>
        </para>
        <para>
          If everything is green, sferes2 is working! If not, please send an e-mail
          to the authors with as many details as possible about your problem.
        </para>
      </section>
      <section id="documentation.compilation.compilation.configuration_options_in_waf">
        <title><link linkend="documentation.compilation.compilation.configuration_options_in_waf">Configuration
        options in waf</link></title>
        <para>
          Sferes2 employs the waf build system (<ulink url="http://code.google.com/p/waf/">http://code.google.com/p/waf/</ulink>)
          instead of autoconf/automake and make. Waf employs files named <emphasis>wscript</emphasis>
          to describe the compilation process in python.
        </para>
        <para>
          The main wscript of sferes2 accepts the following configuration options:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              --boost-includes=BOOSTINCLUDES : path to the boost directory where
              the includes are e.g. /usr/local/include/boost-1_35
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              --boost-libs=BOOSTLIBS : path to the directory where the boost libs
              are e.g. /usr/local/lib
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              --no-mpi : disable mpi (MPI is automatically disabled if no MPI implementation
              is found)
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              --mpi=MPI : path to MPI [e.g. /usr/lib/openmpi ]
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              --apple : enable Apple (mac OSX) support
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              --tbb=TBB : path to TBB if it's not installed in the default directory
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              --64bits : compile for 64 bits architectures
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              --ppc : compile for PowerPC (tested on IBM Power6)
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              --rpath : set an optional rpath (useful in case of link failure)
            </simpara>
          </listitem>
        </itemizedlist>
        <para>
          To use these options, pass them to the waf script during the configuration
          step. For example:
        </para>
        <para>
<programlisting>./waf configure --mpi /usr/lib/openmpi/</programlisting>
        </para>
        <para>
          The configure options used during the last call of the &quot;configure&quot;
          command are in the file build/configure.options.
        </para>
      </section>
      <section id="documentation.compilation.compilation.additionnalmodules">
        <title><link linkend="documentation.compilation.compilation.additionnalmodules">compiling
        additionnal modules</link></title>
        <para>
          The previous compilation provided you with a minimal sferes install. Several
          modules are available in the &quot;modules&quot; directory of sferes. Before
          using any of these modules in your experiment, you must compile these modules
          using sferes.
        </para>
        <para>
          To do so, create a file named &quot;modules.conf&quot; at the root of sferes
          install (where waf is). You should then list the modules you want to use
          in this file, with one module per line.
        </para>
        <para>
          for example, if you want to use the modules cartpole and nn2, your modules.conf
          file should look like:
        </para>
        <para>
<programlisting>cartpole
nn2</programlisting>
        </para>
        <para>
          if you are using the command line, you can create and fill the file the
          following way:
        </para>
        <para>
<programlisting>touch modules.conf
echo nn2 &gt;&gt; modules.conf
echo cartpole &gt;&gt; modules.conf
</programlisting>
        </para>
        <para>
          you should then recompile sferes with the updated file :
        </para>
        <para>
<programlisting>./waf build</programlisting>
        </para>
        <para>
          This should generate test files in the build/default/modules/nn2 and build/default/modules/cartpole
        </para>
        <para>
          You can then run the tests by using the waf check:
        </para>
        <para>
<programlisting>./waf check</programlisting>
        </para>
        <para>
          <emphasis role="bold">WARNING</emphasis> Some tests, namely test_esn and
          test_hyper_nn may not work out of the box. But unless you use these specific
          modules, they should not impact the rest of the code.
        </para>
      </section>
    </section>
  </section>
  <section id="documentation.tutorial">
    <title><link linkend="documentation.tutorial">Tutorial</link></title>
    <para>
      This short example shows how to set up a basic experiment to optimize parameters
      using a user-defined fitness.
    </para>
    <section id="documentation.tutorial.running_a_sferes2_executable">
      <title><link linkend="documentation.tutorial.running_a_sferes2_executable">Running
      a sferes2 executable</link></title>
      <para>
        Waf put all the compiled files in the &quot;build&quot; directory. Two variants
        are produced: &quot;default&quot; and &quot;debug&quot;. You should always
        run the debug version first because the default version disables assert.
        Each variant mirrors the architecture of the main sferes2 directory.
      </para>
      <para>
        Sferes2 contains some basic examples in the &quot;examples&quot; directory.
        For instance, let's check &quot;ex_ea.cpp&quot;, a basic single-objective
        optimization of parameters. To launch the debug version, you should run:
      </para>
      <para>
<programlisting>build/debug/examples/ex_ea</programlisting>
      </para>
      <para>
        A verbose mode is also available:
<programlisting>build/debug/examples/ex_ea -v all</programlisting>
      </para>
      <para>
        And a more verbose one:
<programlisting>build/debug/examples/ex_ea -v all -v trace</programlisting>
      </para>
      <para>
        For the optimized version:
<programlisting>build/default/examples/ex_ea</programlisting>
      </para>
      <para>
        Running one of those commands should create a directory named using the schema
        hostame_pid-year-month-day_hours:min:seconds. In this directory there are:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            a file called &quot;bestfit.dat&quot;, which contains, for each generation,
            the value of the best fitness;
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            many files calles gen_xxx where xxx is a number.
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        These files are XML files which store the best candidates solutions for each
        generation (xxx is the generation number). For instance:
      </para>
      <para>
<programlisting>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; standalone=&quot;yes&quot; ?&gt;
&lt;!DOCTYPE boost_serialization&gt;
&lt;boost_serialization signature=&quot;serialization::archive&quot; version=&quot;5&quot;&gt;
  &lt;x class_id=&quot;0&quot; tracking_level=&quot;0&quot; version=&quot;0&quot;&gt;
    &lt;_best class_id=&quot;1&quot; tracking_level=&quot;0&quot; version=&quot;1&quot;&gt;
      &lt;px class_id=&quot;2&quot; tracking_level=&quot;1&quot; version=&quot;0&quot; object_id=&quot;_0&quot;&gt;
	&lt;_gen class_id=&quot;3&quot; tracking_level=&quot;0&quot; version=&quot;0&quot;&gt;
	  &lt;_data&gt;
	    &lt;count&gt;10&lt;/count&gt;
	    &lt;item_version&gt;0&lt;/item_version&gt;
	    &lt;item&gt;0.50000423&lt;/item&gt;
	    &lt;item&gt;0.49999771&lt;/item&gt;
	    &lt;item&gt;0.49999756&lt;/item&gt;
	    &lt;item&gt;0.49999699&lt;/item&gt;
	    &lt;item&gt;0.50000197&lt;/item&gt;
	    &lt;item&gt;0.49999171&lt;/item&gt;
	    &lt;item&gt;0.5000003&lt;/item&gt;
	    &lt;item&gt;0.50000542&lt;/item&gt;
	    &lt;item&gt;0.50002229&lt;/item&gt;
	    &lt;item&gt;0.49999493&lt;/item&gt;
	  &lt;/_data&gt;
	&lt;/_gen&gt;
	&lt;_fit class_id=&quot;5&quot; tracking_level=&quot;0&quot; version=&quot;0&quot;&gt;
	  &lt;_value&gt;-4.0586573e-14&lt;/_value&gt;
	  &lt;_objs&gt;
	    &lt;count&gt;0&lt;/count&gt;
	    &lt;item_version&gt;0&lt;/item_version&gt;
	  &lt;/_objs&gt;
	&lt;/_fit&gt;
      &lt;/px&gt;
    &lt;/_best&gt;
  &lt;/x&gt;
  &lt;x class_id=&quot;6&quot; tracking_level=&quot;0&quot; version=&quot;0&quot;&gt;
    &lt;_mean&gt;-5376.9888&lt;/_mean&gt;
  &lt;/x&gt;
&lt;/boost_serialization&gt;
</programlisting>
      </para>
      <para>
        This XML file mirrors the statistics used in this experiment (more about
        this in the next sections). At this point of this overview, you can check:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            the _data subtree which lists the values of the &quot;optimal&quot; parameters
            (the result of the experiment);
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            the _fit subtree which shows the fitness value of this &quot;optimal&quot;
            individual;
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            the _mean value which corresponds to the mean fitness in the population
            (another statistics);
          </simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section id="documentation.tutorial.loading_a_result_file">
      <title><link linkend="documentation.tutorial.loading_a_result_file">Loading
      a result file</link></title>
      <para>
        These XML files can be easily post-processed in your favorite language if
        needed. However, the same executable which generated the result files can
        also read them using the following syntax in the experience directory :
<programlisting>../build/default/examples/ex_ea --load gen_1000 -o output_file -n number</programlisting>
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            gen_1000 is the generation file you want to load
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            output_file is a text file which, most of the time (depending on the
            genotype and phenotype used), describes the best individual (or the Pareto-optimal
            set in multiobjective optimization); in this example, it contains the
            value of the parameters for the best individual:
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
<programlisting>cat output_file
8.46386e-05 -4.58956e-05 -4.88758e-05 -6.02007e-05 3.93391e-05 -0.000165701 5.96046e-06 0.00010848 0.000445843 -0.000101328</programlisting>
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            number is the number of the individual described in the file you want
            to load.
          </simpara>
        </listitem>
      </itemizedlist>
    </section>
    <section id="documentation.tutorial.building_your_own_experiment">
      <title><link linkend="documentation.tutorial.building_your_own_experiment">Building
      your own experiment</link></title>
      <section id="documentation.tutorial.building_your_own_experiment.setting_everything_up">
        <title><link linkend="documentation.tutorial.building_your_own_experiment.setting_everything_up">Setting
        everything up</link></title>
        <section id="documentation.tutorial.building_your_own_experiment.setting_everything_up.create_directories_and_files">
          <title><link linkend="documentation.tutorial.building_your_own_experiment.setting_everything_up.create_directories_and_files">Create
          directories and files</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                At the root of the sferes repository (the main directory), use waf
                to create a new experiment. Let's call it &quot;test&quot;:
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting>./waf --create test</programlisting>
          </para>
          <para>
            This should have created a new directory exp/test, a waf file exp/test/wscript
            and a basic file exp/test/test.cpp. You can now edit/customize them.
          </para>
        </section>
        <section id="documentation.tutorial.building_your_own_experiment.setting_everything_up.compiling">
          <title><link linkend="documentation.tutorial.building_your_own_experiment.setting_everything_up.compiling">Compiling</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                In the main sferes2 directory (not in the experiment's directory):
<programlisting>./waf --exp my_exp</programlisting>
                If the experiment is called &quot;test&quot;, the command line is:
<programlisting>./waf --exp test</programlisting>
              </simpara>
            </listitem>
          </itemizedlist>
        </section>
        <section id="documentation.tutorial.building_your_own_experiment.setting_everything_up.running">
          <title><link linkend="documentation.tutorial.building_your_own_experiment.setting_everything_up.running">Running</link></title>
          <para>
<programlisting>cd exp/test
../../build/debug/exp/test/test</programlisting>
            and for the optimized version:
<programlisting>../../build/default/exp/test/test</programlisting>
          </para>
        </section>
      </section>
      <section id="documentation.tutorial.building_your_own_experiment.customizing___writing_the_experiment">
        <title><link linkend="documentation.tutorial.building_your_own_experiment.customizing___writing_the_experiment">Customizing
        / writing the experiment</link></title>
        <para>
          Let's start with exp/test/test.cpp, <emphasis>from the end of the file</emphasis>.
        </para>
        <section id="documentation.tutorial.building_your_own_experiment.customizing___writing_the_experiment.main_function">
          <title><link linkend="documentation.tutorial.building_your_own_experiment.customizing___writing_the_experiment.main_function">Main
          function</link></title>
          <para>
            At the end of the file, you should see a main() function. It defines
            some types using typedef then run the evolutionary algorithm. The types
            describe our experiment (what kind of genotype? what kind of fitness?
            what kind of algorithm?). We will go back to the Params class in the
            following section. Ignore it for now.
          </para>
          <para>
<programlisting><phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">argc</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="special">**</phrase><phrase role="identifier">argv</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="comment">// Our fitness is the class FitTest (see above), that we call</phrase>
  <phrase role="comment">// fit_t. Params is the set of parameters (struct Params) defined in</phrase>
  <phrase role="comment">// this file.</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">FitTest</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">fit_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// We define the genotype. Here we choose EvoFloat (real</phrase>
  <phrase role="comment">// numbers). We evolve 10 real numbers, with the params defined in</phrase>
  <phrase role="comment">// Params (cf the beginning of this file)</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoFloat</phrase><phrase role="special">&lt;</phrase><phrase role="number">10</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">gen_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// This genotype should be simply transformed into a vector of</phrase>
  <phrase role="comment">// parameters (phen::Parameters). The genotype could also have been</phrase>
  <phrase role="comment">// transformed into a shape, a neural network... The phenotype need</phrase>
  <phrase role="comment">// to know which fitness to use; we pass fit_t to it.</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">Parameters</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">fit_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">phen_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// The evaluator is in charge of distributing the evaluation of the</phrase>
  <phrase role="comment">// population. It can be simple eval::Eval (nothing special),</phrase>
  <phrase role="comment">// parallel (for multicore machines, eval::Parallel) or distributed</phrase>
  <phrase role="comment">// (for clusters, eval::Mpi).</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">eval</phrase><phrase role="special">::</phrase><phrase role="identifier">Eval</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// Statistics gather data about the evolutionary process (mean</phrase>
  <phrase role="comment">// fitness, Pareto front, ...). Since they can also store the best</phrase>
  <phrase role="comment">// individuals, they are the container of our results. We can add as</phrase>
  <phrase role="comment">// many statistics as required thanks to the boost::fusion::vector.</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">fusion</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">stat</phrase><phrase role="special">::</phrase><phrase role="identifier">BestFit</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">stat</phrase><phrase role="special">::</phrase><phrase role="identifier">MeanFit</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>  <phrase role="identifier">stat_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// Modifiers are functors which are run once all individuals have</phrase>
  <phrase role="comment">// been evalutated. Their typical use is to add some evolutionary</phrase>
  <phrase role="comment">// pressures towards diversity (e.g. fitness sharing). Here we don't</phrase>
  <phrase role="comment">// use this feature. As a consequence we use a &quot;dummy&quot; modifier that</phrase>
  <phrase role="comment">// does nothing.</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">modif</phrase><phrase role="special">::</phrase><phrase role="identifier">Dummy</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="identifier">modifier_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// We can finally put everything together. RankSimple is the</phrase>
  <phrase role="comment">// evolutionary algorithm. It is parametrized by the phenotype, the</phrase>
  <phrase role="comment">// evaluator, the statistics list, the modifier and the general params.</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">ea</phrase><phrase role="special">::</phrase><phrase role="identifier">RankSimple</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">stat_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">modifier_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">ea_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// We now have a special class for our experiment: ea_t. The next</phrase>
  <phrase role="comment">// line instantiates an object of this class</phrase>
  <phrase role="identifier">ea_t</phrase> <phrase role="identifier">ea</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// We can now process the command line options and run the</phrase>
  <phrase role="comment">// evolutionary algorithm (if a --load argument is passed, the file</phrase>
  <phrase role="comment">// is loaded; otherwise, the algorithm is launched).</phrase>
  <phrase role="identifier">run_ea</phrase><phrase role="special">(</phrase><phrase role="identifier">argc</phrase><phrase role="special">,</phrase> <phrase role="identifier">argv</phrase><phrase role="special">,</phrase> <phrase role="identifier">ea</phrase><phrase role="special">);</phrase>
  <phrase role="comment">//</phrase>
  <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase></programlisting>
          </para>
        </section>
        <section id="documentation.tutorial.building_your_own_experiment.customizing___writing_the_experiment.include_part">
          <title><link linkend="documentation.tutorial.building_your_own_experiment.customizing___writing_the_experiment.include_part">Include
          part</link></title>
          <para>
            Let's now go back to the top of the file. The file starts with the usual
            include files, which obviously depends on which classes (genotype, phenotype,
            ea, ...) you selected in the main function:
          </para>
          <para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">phen</phrase><phrase role="special">/</phrase><phrase role="identifier">parameters</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">gen</phrase><phrase role="special">/</phrase><phrase role="identifier">evo_float</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">ea</phrase><phrase role="special">/</phrase><phrase role="identifier">rank_simple</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">eval</phrase><phrase role="special">/</phrase><phrase role="identifier">eval</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">stat</phrase><phrase role="special">/</phrase><phrase role="identifier">best_fit</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">stat</phrase><phrase role="special">/</phrase><phrase role="identifier">mean_fit</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">modif</phrase><phrase role="special">/</phrase><phrase role="identifier">dummy</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">run</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase></programlisting>
          </para>
        </section>
        <section id="documentation.tutorial.building_your_own_experiment.customizing___writing_the_experiment.params">
          <title><link linkend="documentation.tutorial.building_your_own_experiment.customizing___writing_the_experiment.params">Params</link></title>
          <para>
            Then, the Params structure defines the parameters of the algorithm. This
            particular way of setting them allows the compiler to propagate constants
            to the whole programm (i.e. it replaces the parameters in the code by
            their values), allowing some optimizations. This parameters will depend
            on the algorithms you chose to use in your main function.
          </para>
          <para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">Params</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">evo_float</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">// we choose the polynomial mutation type</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">mutation_t</phrase> <phrase role="identifier">mutation_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">polynomial</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// we choose the polynomial cross-over type</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">cross_over_t</phrase> <phrase role="identifier">cross_over_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">sbx</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// the mutation rate of the real-valued vector</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">mutation_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// a parameter of the polynomial mutation</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_m</phrase> <phrase role="special">=</phrase> <phrase role="number">15.0f</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// a parameter of the polynomial cross-over</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_c</phrase> <phrase role="special">=</phrase> <phrase role="number">10.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">pop</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">// size of the population</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="identifier">size</phrase> <phrase role="special">=</phrase> <phrase role="number">200</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// number of generations</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="identifier">nb_gen</phrase> <phrase role="special">=</phrase> <phrase role="number">2000</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// how often should the result file be written (here, each 5</phrase>
    <phrase role="comment">// generation)</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">dump_period</phrase> <phrase role="special">=</phrase> <phrase role="number">5</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// how many individuals should be created during the random</phrase>
    <phrase role="comment">// generation process?</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">initial_aleat</phrase> <phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// used by RankSimple to select the pressure</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">coeff</phrase> <phrase role="special">=</phrase> <phrase role="number">1.1f</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// the number of individuals which are kept from one generation to</phrase>
    <phrase role="comment">// another (elitism)</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">keep_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.6f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">parameters</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">// maximum value of the phenotype parameters</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">min</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="number">10.0f</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// minimum value</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">max</phrase> <phrase role="special">=</phrase> <phrase role="number">10.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
<phrase role="special">};</phrase></programlisting>
          </para>
        </section>
        <section id="documentation.tutorial.building_your_own_experiment.customizing___writing_the_experiment.fitness_function">
          <title><link linkend="documentation.tutorial.building_your_own_experiment.customizing___writing_the_experiment.fitness_function">Fitness
          function</link></title>
          <para>
            Last, it's time to write the fitness function. It's a special class with
            an &quot;eval()&quot; function which derives from fit::Fitness. It has
            to fill this-&gt;_value in single-objective optimization and this-&gt;_objs
            in multiobjective optimization. In this example, we want to maximize
            -\sum_i p_i^4, where p is the individual's phenotype.
          </para>
          <para>
<programlisting><phrase role="identifier">SFERES_FITNESS</phrase><phrase role="special">(</phrase><phrase role="identifier">FitTest</phrase><phrase role="special">,</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">Fitness</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
 <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
  <phrase role="comment">// indiv will have the type defined in the main (phen_t)</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">ind</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">float</phrase> <phrase role="identifier">v</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="keyword">unsigned</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
	<phrase role="keyword">float</phrase> <phrase role="identifier">p</phrase> <phrase role="special">=</phrase> <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">data</phrase><phrase role="special">(</phrase><phrase role="identifier">i</phrase><phrase role="special">);</phrase>
	<phrase role="identifier">v</phrase> <phrase role="special">+=</phrase> <phrase role="identifier">p</phrase> <phrase role="special">*</phrase> <phrase role="identifier">p</phrase> <phrase role="special">*</phrase> <phrase role="identifier">p</phrase> <phrase role="special">*</phrase> <phrase role="identifier">p</phrase><phrase role="special">;</phrase>
      <phrase role="special">}</phrase>
    <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_value</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="identifier">v</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">};</phrase></programlisting>
          </para>
        </section>
      </section>
    </section>
  </section>
  <section id="documentation.tutorial_neuro">
    <title><link linkend="documentation.tutorial_neuro">Neurobiology Tutorial I</link></title>
    <para>
      This page provides a step-by-step approach for neuroscientists wanting to optimize
      their models using sferes. In the course of this work you will learn how to
      optimise the number values of a fixed model. A second tutorial is available
      for people who want to optimize the topology of models using evoneuro. For
      all the tutorials, a complete code is available at the bottom of the webpage.
    </para>
    <section id="documentation.tutorial_neuro.download_and_install_sferes2">
      <title><link linkend="documentation.tutorial_neuro.download_and_install_sferes2">Download
      and install Sferes2</link></title>
      <para>
        The first step is to install and compile Sferes2. To do so, please follow
        the <link linkend="documentation.download">download</link> and <link linkend="documentation.compilation">compile</link>
        pages before continuing. If you have successfully followed these two pages,
        you should be in the &quot;trunk&quot; directory of sferes2, else, type the
        following command after replacing SFERES2_PARENT_DIRECTORY by the path where
        you put sferes2:
      </para>
      <para>
<programlisting>cd SFERES2_PARENT_DIRECTORY/sferes2/trunk</programlisting>
      </para>
    </section>
    <section id="documentation.tutorial_neuro.create_a_new_experiment">
      <title><link linkend="documentation.tutorial_neuro.create_a_new_experiment">Create
      a new experiment</link></title>
      <para>
        To create a new experiment in sferes, you must first create its directory
        and go in it. You should replace &quot;test&quot; by the name of your new
        experiment in all the following command lines.
      </para>
      <para>
<programlisting>./waf --create test</programlisting>
      </para>
      <para>
        This should have created a new directory exp/test, a waf file exp/test/wscript
        which is used to compile the experiment, and a basic file exp/test/test.cpp.
        You can now edit/customize them.
      </para>
      <para>
        In the next section, we will transform the sample experiment provided to
        create a neural network using the NN2 module. This experiment will optimise
        the weights and bias parameters of a hand made feed-forward network with
        a set number of hidden neurons. The objective of this network will be to
        approximate a simple 3D gaussian function (two inputs, one output).
      </para>
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../img/nn1.png"></imagedata></imageobject>
        <textobject>
          <phrase>nn1</phrase>
        </textobject>
        </inlinemediaobject>
      </para>
    </section>
    <section id="documentation.tutorial_neuro.add_the_nn2_module_to_our_experiment">
      <title><link linkend="documentation.tutorial_neuro.add_the_nn2_module_to_our_experiment">Add
      the nn2 module to our experiment</link></title>
      <para>
        nn2 is a module available in the sferes archive you have downloaded. you
        should have added it already to the list in your &quot;modules.conf&quot;
        file. If not, <link linkend="documentation.compilation.compilation.additionnalmodules">do
        it now</link>.
      </para>
      <para>
        we can now add a neural network to our experiment. To do so, we need to do
        three things:
      </para>
    </section>
    <section id="documentation.tutorial_neuro.update_the_wscript_configuration_file">
      <title><link linkend="documentation.tutorial_neuro.update_the_wscript_configuration_file">Update
      the wscript configuration file</link></title>
      <para>
        We must add the library EIGEN2, required by nn2 module in the list of the
        required uselib section of the file exp/test/wscript.
      </para>
      <para>
<programlisting><phrase role="comment">#! /usr/bin/env python</phrase>
<phrase role="keyword">def</phrase> <phrase role="identifier">build</phrase><phrase role="special">(</phrase><phrase role="identifier">bld</phrase><phrase role="special">):</phrase>
    <phrase role="identifier">obj</phrase> <phrase role="special">=</phrase> <phrase role="identifier">bld</phrase><phrase role="special">.</phrase><phrase role="identifier">new_task_gen</phrase><phrase role="special">(</phrase><phrase role="string">'cxx'</phrase><phrase role="special">,</phrase> <phrase role="string">'program'</phrase><phrase role="special">)</phrase>
    <phrase role="identifier">obj</phrase><phrase role="special">.</phrase><phrase role="identifier">source</phrase> <phrase role="special">=</phrase> <phrase role="string">'test.cpp'</phrase>
    <phrase role="identifier">obj</phrase><phrase role="special">.</phrase><phrase role="identifier">includes</phrase> <phrase role="special">=</phrase> <phrase role="string">'. ../../'</phrase>
    <phrase role="identifier">obj</phrase><phrase role="special">.</phrase><phrase role="identifier">uselib</phrase> <phrase role="special">=</phrase> <phrase role="string">'EIGEN2'</phrase>
    <phrase role="identifier">obj</phrase><phrase role="special">.</phrase><phrase role="identifier">target</phrase> <phrase role="special">=</phrase> <phrase role="string">'test'</phrase>
    <phrase role="identifier">obj</phrase><phrase role="special">.</phrase><phrase role="identifier">uselib_local</phrase> <phrase role="special">=</phrase> <phrase role="string">'sferes2'</phrase>
</programlisting>
      </para>
    </section>
    <section id="documentation.tutorial_neuro.modify_the_parameters">
      <title><link linkend="documentation.tutorial_neuro.modify_the_parameters">Modify
      the parameters</link></title>
      <para>
        We must add the nn2 parameters in the params section of the experiment file
        test.cpp.
      </para>
      <para>
        In sferes, all the parameters which will not change during an experiment
        should be set in the params section. For our experiment, we will just provide
        the number of hidden neurons in our neural network in a fit section of params.
      </para>
      <para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">fit</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_hidden_neurons</phrase> <phrase role="special">=</phrase> <phrase role="number">3</phrase> <phrase role="special">;</phrase>
  <phrase role="identifier">SFERES_ARRAY</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase><phrase role="special">,</phrase><phrase role="identifier">x_pos</phrase><phrase role="special">,</phrase> <phrase role="number">0.69</phrase><phrase role="special">,</phrase> <phrase role="number">0.52</phrase><phrase role="special">,</phrase> <phrase role="number">0.80</phrase><phrase role="special">,</phrase> <phrase role="number">0.95</phrase><phrase role="special">,</phrase> <phrase role="number">0.97</phrase><phrase role="special">,</phrase> <phrase role="number">0.82</phrase><phrase role="special">,</phrase> <phrase role="number">0.11</phrase><phrase role="special">,</phrase> <phrase role="number">0.13</phrase><phrase role="special">,</phrase> <phrase role="number">0.27</phrase><phrase role="special">,</phrase> <phrase role="number">0.59</phrase><phrase role="special">);</phrase>
  <phrase role="identifier">SFERES_ARRAY</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase><phrase role="special">,</phrase><phrase role="identifier">y_pos</phrase><phrase role="special">,</phrase> <phrase role="number">0.24</phrase><phrase role="special">,</phrase> <phrase role="number">0.30</phrase><phrase role="special">,</phrase> <phrase role="number">0.63</phrase><phrase role="special">,</phrase> <phrase role="number">0.30</phrase><phrase role="special">,</phrase> <phrase role="number">0.81</phrase><phrase role="special">,</phrase> <phrase role="number">0.50</phrase><phrase role="special">,</phrase> <phrase role="number">0.47</phrase><phrase role="special">,</phrase> <phrase role="number">0.53</phrase><phrase role="special">,</phrase> <phrase role="number">0.51</phrase><phrase role="special">,</phrase> <phrase role="number">0.66</phrase><phrase role="special">);</phrase>
<phrase role="special">};</phrase>
</programlisting>
      </para>
      <para>
        The two other lines use the macro SFERES_ARRAY which can be used to define
        arrays in the params. The first line defines two functions:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
<programlisting><phrase role="identifier">x_pos</phrase><phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase><phrase role="special">)</phrase></programlisting>
            which returns the float value at index i
          </simpara>
        </listitem>
        <listitem>
          <simpara>
<programlisting><phrase role="identifier">x_pos_size</phrase><phrase role="special">()</phrase></programlisting>
            which returns the size of the array
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        The arrays x_pos and y_pos specify all the positions at which we will assess
        the output of our neural network against the reference function.
      </para>
    </section>
    <section id="documentation.tutorial_neuro.add_the_relevant_include_files">
      <title><link linkend="documentation.tutorial_neuro.add_the_relevant_include_files">Add
      the relevant include files</link></title>
      <para>
        In order to create a neural network, we will now add the relevant include
        file (as well as math.h for our function definition):
      </para>
      <para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">modules</phrase><phrase role="special">/</phrase><phrase role="identifier">nn2</phrase><phrase role="special">/</phrase><phrase role="identifier">nn</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">math</phrase><phrase role="special">.</phrase><phrase role="identifier">h</phrase><phrase role="special">&gt;</phrase>
</programlisting>
      </para>
    </section>
    <section id="documentation.tutorial_neuro.defining_the_function_to_approximate">
      <title><link linkend="documentation.tutorial_neuro.defining_the_function_to_approximate">Defining
      the function to approximate</link></title>
      <para>
        In this test, the function is really simple and computes a gaussian function
        in two dimensions:
      </para>
      <para>
<programlisting><phrase role="keyword">float</phrase> <phrase role="identifier">_gaussian</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">y</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
 <phrase role="keyword">return</phrase> <phrase role="identifier">exp</phrase><phrase role="special">(-(</phrase><phrase role="identifier">x</phrase><phrase role="special">*</phrase><phrase role="identifier">x</phrase><phrase role="special">+</phrase><phrase role="identifier">y</phrase><phrase role="special">*</phrase><phrase role="identifier">y</phrase><phrase role="special">)/</phrase><phrase role="number">2</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
      </para>
      <para>
        We need to put this function in the FitTest class, which is defined by the
        macro SFERES_FITNESS which derives it from the default sferes fitness class.
        This class is the core of all experiments and must define the &quot;eval&quot;
        function which will be called to evaluate each individual in our experiment.
      </para>
    </section>
    <section id="documentation.tutorial_neuro.neural_network_type">
      <title><link linkend="documentation.tutorial_neuro.neural_network_type">Neural
      network type</link></title>
      <para>
        The definition of our network type require several templates to be set. These
        template parameters must be set in the main function of the experiment which
        always contains the following elements:
      </para>
<programlisting><phrase role="special">*</phrase> <phrase role="identifier">The</phrase> <phrase role="identifier">templates</phrase> <phrase role="identifier">parameters</phrase> <phrase role="identifier">of</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">genotype</phrase> <phrase role="keyword">and</phrase> <phrase role="identifier">phenotype</phrase>

<phrase role="special">*</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">declaration</phrase> <phrase role="identifier">of</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">algorithm</phrase> <phrase role="identifier">instanciation</phrase> <phrase role="special">:</phrase> <phrase role="special">[</phrase><phrase role="identifier">teletype</phrase><phrase role="special">]</phrase>ea_t ea;

<phrase role="special">*</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">call</phrase> <phrase role="identifier">to</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">main</phrase> <phrase role="identifier">function</phrase> <phrase role="identifier">of</phrase> <phrase role="identifier">sferes</phrase> <phrase role="identifier">which</phrase> <phrase role="identifier">runs</phrase> <phrase role="identifier">the</phrase> <phrase role="identifier">algorithm</phrase> <phrase role="special">:</phrase>
</programlisting>
      <para>
<programlisting>run_ea(argc, argv, ea);</programlisting>
        . This function parses the user arguments at execution.
      </para>
      <para>
        The first template parameter for a neural network, is the type of values
        passed around the network called &quot;IO&quot;. In our situation, we will
        use float numbers.
      </para>
      <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">io_t</phrase><phrase role="special">;</phrase>
</programlisting>
      </para>
      <para>
        At each activation a neuron will be passed a array of IO (usually a vector).
        and will output a single IO value. The neuron uses two functions to do so:
        a potential function &quot;Pot&quot; and an activation function &quot;Act&quot;.
        in the following way:
      </para>
      <para>
<programlisting>output = Act(Pot(inputs_array))
</programlisting>
      </para>
      <para>
        For our example, we will use a sum function call PfWSum as the potential
        function and a sigmoid like function AfTanh as the activation function. The
        AfTanh requires an additionnal parameter to set a bias in the neuron which
        will be set during the network creation. These two function are defined as
        well as a few other common functions in the files af.hpp and pf.hpp in the
        nn2 module folder. We now can define the type of our neurons in the network:
      </para>
      <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">Neuron</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">PfWSum</phrase><phrase role="special">&lt;&gt;,</phrase> <phrase role="identifier">AfTanh</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">io_t</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">neuron_t</phrase><phrase role="special">;</phrase>

</programlisting>
      </para>
      <para>
        The next thing we need to define is the connection type. Again, we will use
        simple connections which have a single parameter: the weight type. Here,
        the weight type will be a float.
      </para>
      <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">Connection</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">float</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">connection_t</phrase><phrase role="special">;</phrase>
</programlisting>
      </para>
      <para>
        We can now define the complete network type:
      </para>
      <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">NN</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">neuron_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">connection_t</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">nn_t</phrase><phrase role="special">;</phrase>
</programlisting>
      </para>
    </section>
    <section id="documentation.tutorial_neuro.setting_the_number_of_evolved_parameters">
      <title><link linkend="documentation.tutorial_neuro.setting_the_number_of_evolved_parameters">Setting
      the number of evolved parameters</link></title>
      <para>
        We will instantiate a network at each evaluation. The evolved parameters
        will be used for two things:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            setting each neuron bias
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            setting each connection weight
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        We will therefore need a number of evolved parameters 4 times bigger than
        the number of hidden neurons (each hidden neuron has one internal parameters,
        one outbound and two inbound connections). We can now modify the gen_t line
        of the test experiment:
      </para>
      <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoFloat</phrase><phrase role="special">&lt;</phrase><phrase role="number">4</phrase> <phrase role="special">*</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">nb_hidden_neurons</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">gen_t</phrase><phrase role="special">;</phrase>
</programlisting>
      </para>
      <para>
        These parameters will have a value set by the parameters in Params.
      </para>
    </section>
    <section id="documentation.tutorial_neuro.instantiating_the_neural_network">
      <title><link linkend="documentation.tutorial_neuro.instantiating_the_neural_network">Instantiating
      the neural network</link></title>
      <para>
        by using the sekeleton provided, we can create a new network at the beginning
        of the eval function:
      </para>
      <para>
<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase>
   <phrase role="keyword">void</phrase> <phrase role="identifier">_generate_net</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">ind</phrase><phrase role="special">)</phrase>
   <phrase role="special">{</phrase>
     <phrase role="identifier">_hidden_neuron_handles</phrase> <phrase role="special">=</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">neuron_handle_t</phrase><phrase role="special">&gt;(</phrase><phrase role="number">0</phrase><phrase role="special">);</phrase>
     <phrase role="comment">// iterator on the parameters</phrase>
     <phrase role="identifier">size_t</phrase> <phrase role="identifier">k</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
     <phrase role="comment">// set the neural network number of inputs and outputs</phrase>
     <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">set_nb_inputs</phrase><phrase role="special">(</phrase><phrase role="number">2</phrase><phrase role="special">);</phrase>
     <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">set_nb_outputs</phrase><phrase role="special">(</phrase><phrase role="number">1</phrase><phrase role="special">);</phrase>
     <phrase role="comment">// create the hidden neurons and set their internal bias</phrase>
     <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">nb_hidden_neurons</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
     <phrase role="special">{</phrase>
       <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostringstream</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
       <phrase role="identifier">tmp</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">i</phrase><phrase role="special">;</phrase>
       <phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">add_neuron</phrase><phrase role="special">(</phrase><phrase role="identifier">tmp</phrase><phrase role="special">.</phrase><phrase role="identifier">str</phrase><phrase role="special">()));</phrase>
       <phrase role="comment">//set the neuron bias using the evolved parameters</phrase>
       <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_neuron_by_vertex</phrase><phrase role="special">(</phrase><phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">[</phrase><phrase role="identifier">i</phrase><phrase role="special">]).</phrase><phrase role="identifier">set_afparams</phrase><phrase role="special">(</phrase><phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">data</phrase><phrase role="special">(</phrase><phrase role="identifier">k</phrase><phrase role="special">++));</phrase>
     <phrase role="special">}</phrase>
     <phrase role="comment">// create the first layer of connections and set their weight</phrase>
     <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_nb_inputs</phrase><phrase role="special">();++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
     <phrase role="special">{</phrase>
       <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">j</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">j</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();++</phrase><phrase role="identifier">j</phrase><phrase role="special">)</phrase>
       <phrase role="special">{</phrase>
         <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">add_connection</phrase><phrase role="special">(</phrase><phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_input</phrase><phrase role="special">(</phrase><phrase role="identifier">i</phrase><phrase role="special">),</phrase><phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">[</phrase><phrase role="identifier">j</phrase><phrase role="special">],</phrase><phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">data</phrase><phrase role="special">(</phrase><phrase role="identifier">k</phrase><phrase role="special">++));</phrase>
       <phrase role="special">}</phrase>
     <phrase role="special">}</phrase>
      <phrase role="comment">//the output is a real neuron, its bias must be initialised (this is not the case of the inputs) </phrase>
       <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_neuron_by_vertex</phrase><phrase role="special">(</phrase><phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_output</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">)).</phrase><phrase role="identifier">set_afparams</phrase><phrase role="special">(</phrase><phrase role="number">0.0f</phrase><phrase role="special">);</phrase>
     <phrase role="comment">// create the second layer of connections and set their weight</phrase>
     <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">j</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">j</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();++</phrase><phrase role="identifier">j</phrase><phrase role="special">)</phrase>
     <phrase role="special">{</phrase>
       <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">add_connection</phrase><phrase role="special">(</phrase><phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">[</phrase><phrase role="identifier">j</phrase><phrase role="special">],</phrase> <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_output</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">),</phrase> <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">data</phrase><phrase role="special">(</phrase><phrase role="identifier">k</phrase><phrase role="special">++));</phrase>
     <phrase role="special">}</phrase>
   <phrase role="special">}</phrase>
</programlisting>
      </para>
      <para>
        In this function, a few points are important.
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            Input and output neurons are automatically created by the functions set_nb_inputs
            and set_nb_outputs. These functions must be called before creating any
            hidden neurons.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            add_neuron takes a identifier string as parameter and outputs a handle
            to the vertex, not the neuron! You need to use get_neuron_by_vertex to
            get the real neuron.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            While the inputs of the network are not real neurons, the output contains
            Pot and Act functions. Their parameters must set.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            add_connection, which takes as parameters the pre-synaptic neuron, the
            post-synaptic neurons and the weight can take a single value as parameter
            if the number of parameter is equal to one, or an array if there are
            more parameters.
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        The variables used : &quot;_hidden_neuron_handles&quot; and &quot;_nn1&quot;
        must also be added in the protected section of the class.
      </para>
      <para>
<programlisting><phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">neuron_handle_t</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">nn_t</phrase> <phrase role="identifier">_nn1</phrase><phrase role="special">;</phrase>
</programlisting>
      </para>
    </section>
    <section id="documentation.tutorial_neuro.execute_the_neural_network_in_a_loop">
      <title><link linkend="documentation.tutorial_neuro.execute_the_neural_network_in_a_loop">Execute
      the neural network in a loop</link></title>
      <para>
        We can now run the instantiated neural network in a loop and test the points
        defined in Params:
      </para>
      <para>
<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">ind</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="comment">//create the network</phrase>
  <phrase role="identifier">_generate_net</phrase><phrase role="special">(</phrase><phrase role="identifier">ind</phrase><phrase role="special">);</phrase>
  <phrase role="comment">//initialize network (reset accumulators and set the weight buffers if pf)</phrase>
  <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">init</phrase><phrase role="special">();</phrase>
  <phrase role="keyword">float</phrase> <phrase role="identifier">v</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">float</phrase> <phrase role="identifier">tmp_val</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">x_pos_size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">j</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">j</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">y_pos_size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">j</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="comment">//set the network inputs</phrase>
      <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">io_t</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">inputs</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">);</phrase>
      <phrase role="identifier">inputs</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">x_pos</phrase><phrase role="special">(</phrase><phrase role="identifier">i</phrase><phrase role="special">));</phrase>
      <phrase role="identifier">inputs</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">y_pos</phrase><phrase role="special">(</phrase><phrase role="identifier">j</phrase><phrase role="special">));</phrase>
     <phrase role="comment">//iterate the network</phrase>
     <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">k</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">k</phrase> <phrase role="special">&lt;</phrase> <phrase role="number">3</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">k</phrase><phrase role="special">)</phrase>
     <phrase role="special">{</phrase>
       <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">step</phrase><phrase role="special">(</phrase><phrase role="identifier">inputs</phrase><phrase role="special">);</phrase>
     <phrase role="special">}</phrase>
     <phrase role="identifier">tmp_val</phrase><phrase role="special">=(</phrase><phrase role="identifier">_gaussian</phrase><phrase role="special">(</phrase><phrase role="identifier">inputs</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">],</phrase><phrase role="identifier">inputs</phrase><phrase role="special">[</phrase><phrase role="number">1</phrase><phrase role="special">])-</phrase><phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_outf</phrase><phrase role="special">()[</phrase><phrase role="number">0</phrase><phrase role="special">]);</phrase>
     <phrase role="identifier">v</phrase><phrase role="special">+=</phrase><phrase role="identifier">tmp_val</phrase><phrase role="special">*</phrase><phrase role="identifier">tmp_val</phrase><phrase role="special">;</phrase>
    <phrase role="special">}</phrase>
  <phrase role="special">}</phrase>
  <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_value</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="identifier">v</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      </para>
      <para>
        In this function, you should note that initializing the network before using
        it is mandatory. The step function, used three times here cycles through
        the neurons without taking the network topology into account. Therefore,
        you should execute a number of steps equivalent to the depth of the network
        (counting the input neurons) to be sure the output values have been updated.
      </para>
      <para>
        The input neurons do not apply the activation function or the potential function
        on the input vector, on the contrary, the output neurons do.
      </para>
      <para>
        Finally, reading the network outputs is done by the function get_outf() which
        provides an array of io_t of size the numuber of output neurons.
      </para>
    </section>
    <section id="documentation.tutorial_neuro.compiling_and_debugging_the_experiment">
      <title><link linkend="documentation.tutorial_neuro.compiling_and_debugging_the_experiment">Compiling
      and debugging the experiment</link></title>
      <para>
        Once your code is done you can create the binary files for your experiment
        by using the following command:
      </para>
      <para>
<programlisting>./waf --exp test</programlisting>
      </para>
      <para>
        If your code is correct, you should get binary files of your experiment in
        to folders: * in
<programlisting>build/debug/exp/test</programlisting>
        you will find a version compiled with debug information * in
<programlisting>build/default/exp/test</programlisting>
        you will find the final version, with code optimized for speed, but no debug
        information
      </para>
      <para>
        If your code contains errors, two tools may help you debug using the debug
        version : * <ulink url="http://www.valgrind.org/">valgrind</ulink> can be
        used to easily find memory leaks or analyse which parts of your code are
        too slow in combination with <ulink url="http://kcachegrind.sourceforge.net/html/Home.html">kcachegrind</ulink>.
        * <ulink url="http://www.gnu.org/s/gdb/">gdb</ulink> is really useful to
        backtrace errors.
      </para>
    </section>
    <section id="documentation.tutorial_neuro.a_posteriori_analysis_of_solutions">
      <title><link linkend="documentation.tutorial_neuro.a_posteriori_analysis_of_solutions">A
      posteriori analysis of solutions</link></title>
      <para>
        Sferes2 provides several methods to analyse the results of your experiments.
        an experiment in sferes2 will create a new folder in the launch directory
        which should look like that:
      </para>
      <para>
<programlisting>machineneame_2001-01-01_13_52_00_2170</programlisting>
      </para>
      <para>
        and can be decomposed in the following elements separated by an underscore:
        # the hostname of the machine running the experiment (especially usefull
        for running experiments on multiple machines) # the date and hour the run
        was launched # a random generated string to identify the experiment
      </para>
      <para>
        This experiment will contain several files named
<programlisting>gen_X</programlisting>
        with X being the generation. These files contain the pareto front of the
        experiment in xml format (using the <ulink url="http://www.boost.org/doc/libs/1_47_0/libs/serialization/doc/index.html">serialization
        library</ulink> from boost). The interval at which these individuals are
        dumped is defined in the source code by the parameter
<programlisting><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">pop</phrase><phrase role="special">::</phrase><phrase role="identifier">dump_period</phrase></programlisting>
        .
      </para>
      <para>
        If you want to test one of these individuals, you can load it using the executable
        of the experiment from the
<programlisting>build/debug/exp/test/</programlisting>
        directory:
      </para>
      <para>
<programlisting>./test --load=machineneame_2001-01-01_13_52_00_2170/gen_50 --out gna --number 0</programlisting>
      </para>
      <para>
        this will load the generation 50 of the run
<programlisting>machineneame_2001-01-01_13_52_00_2170</programlisting>
        , load the individual number 0 in the file and write the debug information
        in a file named
<programlisting>gna</programlisting>
        .
      </para>
    </section>
    <section id="documentation.tutorial_neuro.adding_code_executed_when_loading_files">
      <title><link linkend="documentation.tutorial_neuro.adding_code_executed_when_loading_files">Adding
      code executed when loading files</link></title>
      <para>
        If you want additionnal debug information, you can define code in the fitness
        function which will only be run when loading files. This is done by using
        the
<programlisting><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">mode</phrase><phrase role="special">()</phrase></programlisting>
        function. This code snippet writes the topology of the loaded network in
        a file named
<programlisting>graph.dot</programlisting>
        .
      </para>
      <para>
<programlisting><phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">mode</phrase><phrase role="special">()</phrase> <phrase role="special">==</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">mode</phrase><phrase role="special">::</phrase><phrase role="identifier">view</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ofstream</phrase> <phrase role="identifier">ofs</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">(</phrase><phrase role="string">&quot;graph.dot&quot;</phrase><phrase role="special">).</phrase><phrase role="identifier">c_str</phrase><phrase role="special">());</phrase>
  <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">write</phrase><phrase role="special">(</phrase><phrase role="identifier">ofs</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
      </para>
      <para>
        the graph.dot file created can then be transformed into a graphical view
        of your network using the dot software (not included in sferes 2 code):
      </para>
      <para>
<programlisting>dot graph.dot -T eps -o graph.eps</programlisting>
      </para>
    </section>
    <section id="documentation.tutorial_neuro.complete_file">
      <title><link linkend="documentation.tutorial_neuro.complete_file">Complete
      file</link></title>
      <para>
        Below is the complete example file:
      </para>
      <para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">phen</phrase><phrase role="special">/</phrase><phrase role="identifier">parameters</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">gen</phrase><phrase role="special">/</phrase><phrase role="identifier">evo_float</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">ea</phrase><phrase role="special">/</phrase><phrase role="identifier">rank_simple</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">eval</phrase><phrase role="special">/</phrase><phrase role="identifier">eval</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">stat</phrase><phrase role="special">/</phrase><phrase role="identifier">best_fit</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">stat</phrase><phrase role="special">/</phrase><phrase role="identifier">mean_fit</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">modif</phrase><phrase role="special">/</phrase><phrase role="identifier">dummy</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">run</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">modules</phrase><phrase role="special">/</phrase><phrase role="identifier">nn2</phrase><phrase role="special">/</phrase><phrase role="identifier">nn</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">math</phrase><phrase role="special">.</phrase><phrase role="identifier">h</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">;</phrase>
<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">evo_float</phrase><phrase role="special">;</phrase>
<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">nn</phrase><phrase role="special">;</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">Params</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">evo_float</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">// we choose the polynomial mutation type</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">mutation_t</phrase> <phrase role="identifier">mutation_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">polynomial</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// we choose the polynomial cross-over type</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">cross_over_t</phrase> <phrase role="identifier">cross_over_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">sbx</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// the mutation rate of the real-valued vector</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">mutation_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// the cross rate of the real-valued vector</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">cross_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.5f</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// a parameter of the polynomial mutation</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_m</phrase> <phrase role="special">=</phrase> <phrase role="number">15.0f</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// a parameter of the polynomial cross-over</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_c</phrase> <phrase role="special">=</phrase> <phrase role="number">10.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">pop</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">// size of the population</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="identifier">size</phrase> <phrase role="special">=</phrase> <phrase role="number">200</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// number of generations</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="identifier">nb_gen</phrase> <phrase role="special">=</phrase> <phrase role="number">2000</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// how often should the result file be written (here, each 5</phrase>
    <phrase role="comment">// generation)</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">dump_period</phrase> <phrase role="special">=</phrase> <phrase role="number">5</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// how many individuals should be created during the random</phrase>
    <phrase role="comment">// generation process?</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">initial_aleat</phrase> <phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// used by RankSimple to select the pressure</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">coeff</phrase> <phrase role="special">=</phrase> <phrase role="number">1.1f</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// the number of individuals that are kept from on generation to</phrase>
    <phrase role="comment">// another (elitism)</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">keep_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.6f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">fit</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_hidden_neurons</phrase> <phrase role="special">=</phrase> <phrase role="number">3</phrase> <phrase role="special">;</phrase>
    <phrase role="identifier">SFERES_ARRAY</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase><phrase role="special">,</phrase><phrase role="identifier">x_pos</phrase><phrase role="special">,</phrase> <phrase role="number">0.69</phrase><phrase role="special">,</phrase> <phrase role="number">0.52</phrase><phrase role="special">,</phrase> <phrase role="number">0.80</phrase><phrase role="special">,</phrase> <phrase role="number">0.95</phrase><phrase role="special">,</phrase> <phrase role="number">0.97</phrase><phrase role="special">,</phrase> <phrase role="number">0.82</phrase><phrase role="special">,</phrase> <phrase role="number">0.11</phrase><phrase role="special">,</phrase> <phrase role="number">0.13</phrase><phrase role="special">,</phrase> <phrase role="number">0.27</phrase><phrase role="special">,</phrase> <phrase role="number">0.59</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">SFERES_ARRAY</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase><phrase role="special">,</phrase><phrase role="identifier">y_pos</phrase><phrase role="special">,</phrase> <phrase role="number">0.24</phrase><phrase role="special">,</phrase> <phrase role="number">0.30</phrase><phrase role="special">,</phrase> <phrase role="number">0.63</phrase><phrase role="special">,</phrase> <phrase role="number">0.30</phrase><phrase role="special">,</phrase> <phrase role="number">0.81</phrase><phrase role="special">,</phrase> <phrase role="number">0.50</phrase><phrase role="special">,</phrase> <phrase role="number">0.47</phrase><phrase role="special">,</phrase> <phrase role="number">0.53</phrase><phrase role="special">,</phrase> <phrase role="number">0.51</phrase><phrase role="special">,</phrase> <phrase role="number">0.66</phrase><phrase role="special">);</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">parameters</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">// maximum value of parameters</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">min</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="number">10.0f</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// minimum value</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">max</phrase> <phrase role="special">=</phrase> <phrase role="number">10.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
<phrase role="special">};</phrase>

<phrase role="identifier">SFERES_FITNESS</phrase><phrase role="special">(</phrase><phrase role="identifier">FitTest</phrase><phrase role="special">,</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">Fitness</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">io_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">Neuron</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">PfWSum</phrase><phrase role="special">&lt;&gt;,</phrase> <phrase role="identifier">AfTanh</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">io_t</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">neuron_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">Connection</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">float</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">connection_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">NN</phrase><phrase role="special">&lt;</phrase> <phrase role="identifier">neuron_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">connection_t</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">nn_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">nn_t</phrase><phrase role="special">::</phrase><phrase role="identifier">vertex_desc_t</phrase> <phrase role="identifier">neuron_handle_t</phrase><phrase role="special">;</phrase>
 <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
  <phrase role="comment">// indiv will have the type defined in the main (phen_t)</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">ind</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">//create the network</phrase>
    <phrase role="identifier">_generate_net</phrase><phrase role="special">(</phrase><phrase role="identifier">ind</phrase><phrase role="special">);</phrase>
    <phrase role="comment">//initialize network (reset accumulators and set the weight buffers if pf)</phrase>
    <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">init</phrase><phrase role="special">();</phrase>
    <phrase role="keyword">float</phrase> <phrase role="identifier">v</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">float</phrase> <phrase role="identifier">tmp_val</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">x_pos_size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">j</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">j</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">y_pos_size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">j</phrase><phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
        <phrase role="comment">//set the network inputs</phrase>
        <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">io_t</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">inputs</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">);</phrase>
        <phrase role="identifier">inputs</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">x_pos</phrase><phrase role="special">(</phrase><phrase role="identifier">i</phrase><phrase role="special">));</phrase>
        <phrase role="identifier">inputs</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">y_pos</phrase><phrase role="special">(</phrase><phrase role="identifier">j</phrase><phrase role="special">));</phrase>
       <phrase role="comment">//iterate the network</phrase>
       <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">k</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">k</phrase> <phrase role="special">&lt;</phrase> <phrase role="number">3</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">k</phrase><phrase role="special">)</phrase>
       <phrase role="special">{</phrase>
         <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">step</phrase><phrase role="special">(</phrase><phrase role="identifier">inputs</phrase><phrase role="special">);</phrase>
       <phrase role="special">}</phrase>
       <phrase role="identifier">tmp_val</phrase><phrase role="special">=(</phrase><phrase role="identifier">_gaussian</phrase><phrase role="special">(</phrase><phrase role="identifier">inputs</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">],</phrase><phrase role="identifier">inputs</phrase><phrase role="special">[</phrase><phrase role="number">1</phrase><phrase role="special">])-</phrase><phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_outf</phrase><phrase role="special">()[</phrase><phrase role="number">0</phrase><phrase role="special">]);</phrase>
       <phrase role="identifier">v</phrase><phrase role="special">+=</phrase><phrase role="identifier">tmp_val</phrase><phrase role="special">*</phrase><phrase role="identifier">tmp_val</phrase><phrase role="special">;</phrase>
      <phrase role="special">}</phrase>
    <phrase role="special">}</phrase>
    <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">mode</phrase><phrase role="special">()</phrase> <phrase role="special">==</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">mode</phrase><phrase role="special">::</phrase><phrase role="identifier">view</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ofstream</phrase> <phrase role="identifier">ofs</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">(</phrase><phrase role="string">&quot;graph.dot&quot;</phrase><phrase role="special">).</phrase><phrase role="identifier">c_str</phrase><phrase role="special">());</phrase>
      <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">write</phrase><phrase role="special">(</phrase><phrase role="identifier">ofs</phrase><phrase role="special">);</phrase>
    <phrase role="special">}</phrase>
    <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_value</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="identifier">v</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
 <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">neuron_handle_t</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">nn_t</phrase> <phrase role="identifier">_nn1</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">float</phrase> <phrase role="identifier">_gaussian</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">y</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">exp</phrase><phrase role="special">(-(</phrase><phrase role="identifier">x</phrase><phrase role="special">*</phrase><phrase role="identifier">x</phrase><phrase role="special">+</phrase><phrase role="identifier">y</phrase><phrase role="special">*</phrase><phrase role="identifier">y</phrase><phrase role="special">)/</phrase><phrase role="number">2</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">_generate_net</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">ind</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="identifier">_hidden_neuron_handles</phrase> <phrase role="special">=</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">neuron_handle_t</phrase><phrase role="special">&gt;(</phrase><phrase role="number">0</phrase><phrase role="special">);</phrase>
      <phrase role="comment">// iterator on the parameters</phrase>
      <phrase role="identifier">size_t</phrase> <phrase role="identifier">k</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
      <phrase role="comment">// set the neural network number of inputs and outputs</phrase>
      <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">set_nb_inputs</phrase><phrase role="special">(</phrase><phrase role="number">2</phrase><phrase role="special">);</phrase>
      <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">set_nb_outputs</phrase><phrase role="special">(</phrase><phrase role="number">1</phrase><phrase role="special">);</phrase>
      <phrase role="comment">// create the hidden neurons and set their internal bias</phrase>
      <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">nb_hidden_neurons</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
        <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostringstream</phrase> <phrase role="identifier">tmp</phrase><phrase role="special">;</phrase>
        <phrase role="identifier">tmp</phrase> <phrase role="special">&lt;&lt;</phrase> <phrase role="identifier">i</phrase><phrase role="special">;</phrase>
        <phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">add_neuron</phrase><phrase role="special">(</phrase><phrase role="identifier">tmp</phrase><phrase role="special">.</phrase><phrase role="identifier">str</phrase><phrase role="special">()));</phrase>
        <phrase role="comment">//set the neuron bias using the evolved parameters</phrase>
        <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_neuron_by_vertex</phrase><phrase role="special">(</phrase><phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">[</phrase><phrase role="identifier">i</phrase><phrase role="special">]).</phrase><phrase role="identifier">set_afparams</phrase><phrase role="special">(</phrase><phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">data</phrase><phrase role="special">(</phrase><phrase role="identifier">k</phrase><phrase role="special">++));</phrase>
      <phrase role="special">}</phrase>
      <phrase role="comment">//the output is a real neuron, its bias must be initialised </phrase>
      <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_neuron_by_vertex</phrase><phrase role="special">(</phrase><phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_output</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">)).</phrase><phrase role="identifier">set_afparams</phrase><phrase role="special">(</phrase><phrase role="number">0.0f</phrase><phrase role="special">);</phrase>
      <phrase role="comment">// create the first layer of connections and set their weight</phrase>
      <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_nb_inputs</phrase><phrase role="special">();++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
        <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">j</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">j</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();++</phrase><phrase role="identifier">j</phrase><phrase role="special">)</phrase>
        <phrase role="special">{</phrase>
          <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">add_connection</phrase><phrase role="special">(</phrase><phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_input</phrase><phrase role="special">(</phrase><phrase role="identifier">i</phrase><phrase role="special">),</phrase><phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">[</phrase><phrase role="identifier">j</phrase><phrase role="special">],</phrase><phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">data</phrase><phrase role="special">(</phrase><phrase role="identifier">k</phrase><phrase role="special">++));</phrase>
        <phrase role="special">}</phrase>
      <phrase role="special">}</phrase>
      <phrase role="comment">// create the second layer of connections and set their weight</phrase>
      <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">j</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">j</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();++</phrase><phrase role="identifier">j</phrase><phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
        <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">add_connection</phrase><phrase role="special">(</phrase><phrase role="identifier">_hidden_neuron_handles</phrase><phrase role="special">[</phrase><phrase role="identifier">j</phrase><phrase role="special">],</phrase> <phrase role="identifier">_nn1</phrase><phrase role="special">.</phrase><phrase role="identifier">get_output</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">),</phrase> <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">data</phrase><phrase role="special">(</phrase><phrase role="identifier">k</phrase><phrase role="special">++));</phrase>
      <phrase role="special">}</phrase>
    <phrase role="special">}</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">argc</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="special">**</phrase><phrase role="identifier">argv</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="comment">// Our fitness is the class FitTest (see above), that we will call</phrase>
  <phrase role="comment">// fit_t. Params is the set of parameters (struct Params) defined in</phrase>
  <phrase role="comment">// this file.</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">FitTest</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">fit_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// We define the genotype. Here we choose EvoFloat (real</phrase>
  <phrase role="comment">// numbers). We evolve 10 real numbers, with the params defined in</phrase>
  <phrase role="comment">// Params (cf the beginning of this file)</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoFloat</phrase><phrase role="special">&lt;</phrase><phrase role="number">4</phrase> <phrase role="special">*</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">nb_hidden_neurons</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">gen_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// This genotype should be simply transformed into a vector of</phrase>
  <phrase role="comment">// parameters (phen::Parameters). The genotype could also have been</phrase>
  <phrase role="comment">// transformed into a shape, a neural network... The phenotype need</phrase>
  <phrase role="comment">// to know which fitness to use; we pass fit_t.</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">Parameters</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">fit_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">phen_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// The evaluator is in charge of distributing the evaluation of the</phrase>
  <phrase role="comment">// population. It can be simple eval::Eval (nothing special),</phrase>
  <phrase role="comment">// parallel (for multicore machines, eval::Parallel) or distributed</phrase>
  <phrase role="comment">// (for clusters, eval::Mpi).</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">eval</phrase><phrase role="special">::</phrase><phrase role="identifier">Eval</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// Statistics gather data about the evolutionary process (mean</phrase>
  <phrase role="comment">// fitness, Pareto front, ...). Since they can also stores the best</phrase>
  <phrase role="comment">// individuals, they are the container of our results. We can add as</phrase>
  <phrase role="comment">// many statistics as required thanks to the boost::fusion::vector.</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">fusion</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">stat</phrase><phrase role="special">::</phrase><phrase role="identifier">BestFit</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">stat</phrase><phrase role="special">::</phrase><phrase role="identifier">MeanFit</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>  <phrase role="identifier">stat_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// Modifiers are functors that are run once all individuals have</phrase>
  <phrase role="comment">// been evalutated. Their typical use is to add some evolutionary</phrase>
  <phrase role="comment">// pressures towards diversity (e.g. fitness sharing). Here we don't</phrase>
  <phrase role="comment">// use this feature. As a consequence we use a &quot;dummy&quot; modifier that</phrase>
  <phrase role="comment">// does nothing.</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">modif</phrase><phrase role="special">::</phrase><phrase role="identifier">Dummy</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="identifier">modifier_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// We can finally put everything together. RankSimple is the</phrase>
  <phrase role="comment">// evolutianary algorithm. It is parametrized by the phenotype, the</phrase>
  <phrase role="comment">// evaluator, the statistics list, the modifier and the general params.</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">ea</phrase><phrase role="special">::</phrase><phrase role="identifier">RankSimple</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">stat_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">modifier_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">ea_t</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// We now have a special class for our experiment: ea_t. The next</phrase>
  <phrase role="comment">// line instantiate an object of this class</phrase>
  <phrase role="identifier">ea_t</phrase> <phrase role="identifier">ea</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// we can now process the comannd line options an run the</phrase>
  <phrase role="comment">// evolutionary algorithm (if a --load argument is passed, the file</phrase>
  <phrase role="comment">// is loaded; otherwise, the algorithm is launched).</phrase>
  <phrase role="identifier">run_ea</phrase><phrase role="special">(</phrase><phrase role="identifier">argc</phrase><phrase role="special">,</phrase> <phrase role="identifier">argv</phrase><phrase role="special">,</phrase> <phrase role="identifier">ea</phrase><phrase role="special">);</phrase>
  <phrase role="comment">//</phrase>
  <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>

</programlisting>
      </para>
    </section>
  </section>
  <section id="documentation.tutorial_topo">
    <title><link linkend="documentation.tutorial_topo">Neurobiology Tutorial II</link></title>
    <para>
      This second tutorial will guide you through the process of evolving not only
      the weights, but also the topology of a neural network. Using the nn2 module
      from sferes2, we will test both the evolution of a a recurrent network on the
      same task as <link linkend="documentation.tutorial_neuro">previously</link>
      (function approximation).
    </para>
    <section id="documentation.tutorial_topo.download_and_install_sferes2_and_crete_a_new_experiment">
      <title><link linkend="documentation.tutorial_topo.download_and_install_sferes2_and_crete_a_new_experiment">Download
      and install Sferes2 and crete a new experiment</link></title>
      <para>
        The first step is to install and compile Sferes2. To do so, please follow
        the <link linkend="documentation.download">download</link> and <link linkend="documentation.compilation">compilation</link>
        pages before continuing. If you have successfully followed these two pages,
        you should be in the &quot;trunk&quot; directory of sferes2, else, type the
        following command after replacing $SFERES2_PARENT_DIRECTORY by the path where
        you put sferes2:
      </para>
      <para>
<programlisting>cd $SFERES2_PARENT_DIRECTORY/sferes2/trunk</programlisting>
      </para>
      <para>
        you should now create a new experiment:
      </para>
      <para>
<programlisting>./waf --create test2</programlisting>
      </para>
      <para>
        We can now enter the experiment source code and edit the wscript to add the
        necessary modules:
      </para>
      <para>
<programlisting>cd exp/test2
edit wscript
</programlisting>
      </para>
      <para>
        The required modules are the same as the previous tutorial:
      </para>
      <para>
<programlisting>#! /usr/bin/env python
def build(bld):
    obj = bld.new_task_gen('cxx', 'program')
    obj.source = 'test2.cpp'
    obj.includes = '. ../../'
    obj.uselib = 'EIGEN2'
    obj.target = 'test2'
    obj.uselib_local = 'sferes2'
</programlisting>
      </para>
      <para>
        we can then edit the source code for our new experiment: test2.cpp.
      </para>
    </section>
    <section id="documentation.tutorial_topo.add_headers">
      <title><link linkend="documentation.tutorial_topo.add_headers">Add the relevant
      headers</link></title>
      <para>
        Unlike the previous tutorial, we are going to include headers that wrap the
        previous neural network code with functions to generate random topologies
        and evolve them.
      </para>
      <para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">modules</phrase><phrase role="special">/</phrase><phrase role="identifier">nn2</phrase><phrase role="special">/</phrase><phrase role="identifier">gen_dnn</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">modules</phrase><phrase role="special">/</phrase><phrase role="identifier">nn2</phrase><phrase role="special">/</phrase><phrase role="identifier">phen_dnn</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">dnn</phrase><phrase role="special">;</phrase>
</programlisting>
      </para>
      <para>
        If you look at these files, you will see that a few methods have been added
        to evolve the topology of neural networks. In the genotype, you will find
        the following methods:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            random() initializes a genotype randomly (using the parameters from Params).
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            mutate() randomly changes the network by adding, removing or changing
            nodes and connections ( using the probabilities stated in params).
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            cross(parent1, parent2) initializes the network genotype as a random
            of one of the two parents.
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        the phenotype file provides the following methods:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            develop() must be called to initialize a genotype (fill in the parameters)
            and is mandatory before using a network.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            show(ostream out) dumps the network topology to a dot file.
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            nn() returns a reference to the neural network in the phenotype.
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        Finally, we need the dnn namespace.
      </para>
    </section>
    <section id="documentation.tutorial_topo.define_the_necessary_parameters">
      <title><link linkend="documentation.tutorial_topo.define_the_necessary_parameters">Define
      the necessary parameters</link></title>
      <para>
        Again, we need to define the required parameters for our networks, the main
        addition concerns the mutation rates:
      </para>
      <para>
<programlisting>  <phrase role="keyword">struct</phrase> <phrase role="identifier">evo_float</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">mutation_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">cross_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">mutation_t</phrase> <phrase role="identifier">mutation_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">polynomial</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">cross_over_t</phrase> <phrase role="identifier">cross_over_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">sbx</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_m</phrase> <phrase role="special">=</phrase> <phrase role="number">15.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_c</phrase> <phrase role="special">=</phrase> <phrase role="number">15.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">parameters</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">// maximum value of parameters</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">min</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="number">5.0f</phrase><phrase role="special">;</phrase>
    <phrase role="comment">// minimum value</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">max</phrase> <phrase role="special">=</phrase> <phrase role="number">5.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">dnn</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_inputs</phrase> <phrase role="special">=</phrase> <phrase role="number">2</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_outputs</phrase>  <phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">min_nb_neurons</phrase>  <phrase role="special">=</phrase> <phrase role="number">3</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_nb_neurons</phrase>  <phrase role="special">=</phrase> <phrase role="number">10</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">min_nb_conns</phrase>  <phrase role="special">=</phrase> <phrase role="number">100</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_nb_conns</phrase>  <phrase role="special">=</phrase> <phrase role="number">101</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_add_conn</phrase>  <phrase role="special">=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_del_conn</phrase>  <phrase role="special">=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_change_conn</phrase> <phrase role="special">=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_add_neuron</phrase>  <phrase role="special">=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_del_neuron</phrase>  <phrase role="special">=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">io_param_evolving</phrase> <phrase role="special">=</phrase> <phrase role="keyword">true</phrase><phrase role="special">;</phrase>
<phrase role="comment">//    static const init_t init = ff;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">init_t</phrase> <phrase role="identifier">init</phrase> <phrase role="special">=</phrase> <phrase role="identifier">random_topology</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
</programlisting>
      </para>
      <para>
        As previously, you need an evo_float struct which provides the mutation rate
        of the parameters (bias_t) and for the weights (weight_t). If you need different
        values for the two, you can create multiple Params classes and pass them
        as template arguments in your typedefs in the next paragraph.
      </para>
      <para>
        The second struct, parameters, is used to define the scaling of the evo-float
        values (evo_float are between 0 and 1 normally). Again, if you require different
        scaling for the neuron parameters and weights, you can provide separate params.
      </para>
      <para>
        The last struct, dnn, defines several new elements:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            the number of intputs and outputs of the evolved network (it must be
            constant)
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            the minimum and maximum number of neurons in any evolved network
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            the minimum and maximum number of connections in the network
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            probabilities to (in order)
            <itemizedlist>
              <listitem>
                <simpara>
                  add a connection
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  remove a connection
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  change the source or target of a connection
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  add a new neuron (replaces an existing connection)
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  remove a neuron
                </simpara>
              </listitem>
            </itemizedlist>
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        The probability of changing a parameter is defined by the values in the evo_float
        struct. The evolution of parameters of the output nodes can be enabled or
        disabled through the io_param_evolving constant. Finally, the init constant
        is used to define if the initial random network have a feedforward topology
        with no hidden nodes (&quot;ff&quot; value) like NEAT or a random topology
        (random_topology).
      </para>
    </section>
    <section id="documentation.tutorial_topo.declare_the_type_of_our_input_outputs__weights__connections_and_neurons">
      <title><link linkend="documentation.tutorial_topo.declare_the_type_of_our_input_outputs__weights__connections_and_neurons">Declare
      the type of our input/outputs, weights, connections and neurons</link></title>
      <para>
        Similarly to the previous tutorial, we need to define the template parameters
        of our neural network in the main function. However, here, the io_t and weight_t
        are replaced by evo_float which has the mutate, random and cross methods
        (bias_t is the internal bias of the neuron and has the same type as all the
        other inputs io_t). If you use a neuron with more than one parameter, you
        should increase the bias_t size). Finally, we need to set the fitness as
        the algorithm fitness.
      </para>
      <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">Parameters</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoFloat</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">FitDummy</phrase><phrase role="special">&lt;&gt;,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">weight_t</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">Parameters</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoFloat</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">FitDummy</phrase><phrase role="special">&lt;&gt;,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">bias_t</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">PfWSum</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">weight_t</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">pf_t</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">AfTanh</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">bias_t</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">af_t</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">Neuron</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">pf_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">af_t</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">neuron_t</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">Connection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">weight_t</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">connection_t</phrase><phrase role="special">;</phrase>

<phrase role="keyword">typedef</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">Dnn</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">neuron_t</phrase><phrase role="special">,</phrase>  <phrase role="identifier">connection_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">gen_t</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">Dnn</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">FitTest</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">phen_t</phrase><phrase role="special">;</phrase>
</programlisting>
      </para>
    </section>
    <section id="documentation.tutorial_topo.using_the_parallel_evaluation">
      <title><link linkend="documentation.tutorial_topo.using_the_parallel_evaluation">Using
      the parallel evaluation</link></title>
      <para>
        If your sferes has been compiled with tbb, you can evaluate your individuals
        in parallel. This works quite well on HyperThreaded processors by the way.
        However, this is only useful for significant time evaluation. To do so, just
        replace the eval::Eval by eval::Parallel in the main typedefs. This divided
        the runtime of this example from 18,023 seconds to 8,313 seconds using a
        three processor machine.
      </para>
      <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">eval</phrase><phrase role="special">::</phrase><phrase role="identifier">Parallel</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">;</phrase>
</programlisting>
      </para>
    </section>
    <section id="documentation.tutorial_topo.add_code_to_initialise_the_neural_network_and_run_it">
      <title><link linkend="documentation.tutorial_topo.add_code_to_initialise_the_neural_network_and_run_it">add
      code to initialise the neural network and run it</link></title>
      <para>
        We are going to use the neural network in a way similar to the previous tutorial,
        to approximate a function. To do so, we must modify the eval function in
        the fitness class.
      </para>
      <para>
<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="identifier">Indiv</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">ind</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">//initialize network (set weights and parameters, reset accumulators and set the weight buffers if pf)</phrase>
    <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">develop</phrase><phrase role="special">();</phrase>
    <phrase role="keyword">float</phrase> <phrase role="identifier">v</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">float</phrase> <phrase role="identifier">tmp_val</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">x_pos_size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">j</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">j</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">y_pos_size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">j</phrase><phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
        <phrase role="comment">//set the network inputs</phrase>
        <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">float</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">inputs</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">);</phrase>
        <phrase role="identifier">inputs</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">x_pos</phrase><phrase role="special">(</phrase><phrase role="identifier">i</phrase><phrase role="special">));</phrase>
        <phrase role="identifier">inputs</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">y_pos</phrase><phrase role="special">(</phrase><phrase role="identifier">j</phrase><phrase role="special">));</phrase>
       <phrase role="comment">//iterate the network 5 times (if the network is recurrent, additionnal tests could be necessary to test the stability)</phrase>
       <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_iterations</phrase> <phrase role="special">=</phrase> <phrase role="number">5</phrase><phrase role="special">;</phrase>
       <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">k</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">k</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">max_iterations</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">k</phrase><phrase role="special">)</phrase>
       <phrase role="special">{</phrase>
         <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">step</phrase><phrase role="special">(</phrase><phrase role="identifier">inputs</phrase><phrase role="special">);</phrase>
       <phrase role="special">}</phrase>
       <phrase role="identifier">tmp_val</phrase><phrase role="special">=(</phrase><phrase role="identifier">_gaussian</phrase><phrase role="special">(</phrase><phrase role="identifier">inputs</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">],</phrase><phrase role="identifier">inputs</phrase><phrase role="special">[</phrase><phrase role="number">1</phrase><phrase role="special">])-</phrase><phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">get_outf</phrase><phrase role="special">()[</phrase><phrase role="number">0</phrase><phrase role="special">]);</phrase>
       <phrase role="identifier">v</phrase><phrase role="special">+=</phrase><phrase role="identifier">tmp_val</phrase><phrase role="special">*</phrase><phrase role="identifier">tmp_val</phrase><phrase role="special">;</phrase>
      <phrase role="special">}</phrase>
    <phrase role="special">}</phrase>
    <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">mode</phrase><phrase role="special">()</phrase> <phrase role="special">==</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">mode</phrase><phrase role="special">::</phrase><phrase role="identifier">view</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ofstream</phrase> <phrase role="identifier">ofs</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">(</phrase><phrase role="string">&quot;graph.dot&quot;</phrase><phrase role="special">).</phrase><phrase role="identifier">c_str</phrase><phrase role="special">());</phrase>
      <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">write</phrase><phrase role="special">(</phrase><phrase role="identifier">ofs</phrase><phrase role="special">);</phrase>
    <phrase role="special">}</phrase>
    <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_value</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="identifier">v</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
</programlisting>
      </para>
      <para>
        The first modification from the previous version are that we increased the
        number of step done by the network. We also call only the develop method
        from the individual's phenotype and we then use ind.nn() to access its network.
      </para>
      <para>
        we also must add the positions to test in the parameters:
      </para>
      <para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">fit</phrase>
 <phrase role="special">{</phrase>
   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_hidden_neurons</phrase> <phrase role="special">=</phrase> <phrase role="number">3</phrase> <phrase role="special">;</phrase>
   <phrase role="identifier">SFERES_ARRAY</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase><phrase role="special">,</phrase><phrase role="identifier">x_pos</phrase><phrase role="special">,</phrase> <phrase role="number">0.69</phrase><phrase role="special">,</phrase> <phrase role="number">0.52</phrase><phrase role="special">,</phrase> <phrase role="number">0.80</phrase><phrase role="special">,</phrase> <phrase role="number">0.95</phrase><phrase role="special">,</phrase> <phrase role="number">0.97</phrase><phrase role="special">,</phrase> <phrase role="number">0.82</phrase><phrase role="special">,</phrase> <phrase role="number">0.11</phrase><phrase role="special">,</phrase> <phrase role="number">0.13</phrase><phrase role="special">,</phrase> <phrase role="number">0.27</phrase><phrase role="special">,</phrase> <phrase role="number">0.59</phrase><phrase role="special">);</phrase>
   <phrase role="identifier">SFERES_ARRAY</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase><phrase role="special">,</phrase><phrase role="identifier">y_pos</phrase><phrase role="special">,</phrase> <phrase role="number">0.24</phrase><phrase role="special">,</phrase> <phrase role="number">0.30</phrase><phrase role="special">,</phrase> <phrase role="number">0.63</phrase><phrase role="special">,</phrase> <phrase role="number">0.30</phrase><phrase role="special">,</phrase> <phrase role="number">0.81</phrase><phrase role="special">,</phrase> <phrase role="number">0.50</phrase><phrase role="special">,</phrase> <phrase role="number">0.47</phrase><phrase role="special">,</phrase> <phrase role="number">0.53</phrase><phrase role="special">,</phrase> <phrase role="number">0.51</phrase><phrase role="special">,</phrase> <phrase role="number">0.66</phrase><phrase role="special">);</phrase>
 <phrase role="special">};</phrase>
</programlisting>
      </para>
      <para>
        and finally the function to approximate:
      </para>
      <para>
<programlisting><phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
 <phrase role="keyword">float</phrase> <phrase role="identifier">_gaussian</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">y</phrase><phrase role="special">)</phrase>
 <phrase role="special">{</phrase>
   <phrase role="keyword">return</phrase> <phrase role="identifier">exp</phrase><phrase role="special">(-(</phrase><phrase role="identifier">x</phrase><phrase role="special">*</phrase><phrase role="identifier">x</phrase><phrase role="special">+</phrase><phrase role="identifier">y</phrase><phrase role="special">*</phrase><phrase role="identifier">y</phrase><phrase role="special">)/</phrase><phrase role="number">2</phrase><phrase role="special">);</phrase>
 <phrase role="special">}</phrase>
</programlisting>
      </para>
      <para>
        You can now compile the new experiment (view the previous tutorial) and obtain
        networks such as the following one :
      </para>
    </section>
    <section id="documentation.tutorial_topo.using_feedforward_networks_only">
      <title><link linkend="documentation.tutorial_topo.using_feedforward_networks_only">using
      feedforward networks only</link></title>
      <para>
        The dnn genotype can create recursive networks. In order to generate only
        feedforward networks, you can use the gen_dnn_ff.hpp include which is a derivative
        class from gen_dnn.hpp.
      </para>
      <para>
        As we want to create both an experiment using dnn and dnn_ff with the same
        codebase, we are going to use a feature from sferes2, called variants to
        generate two different binaries from a single source code.
      </para>
      <para>
        First, we need to replace the previosu wscript to tell the compiler to create
        two binaries
      </para>
      <para>
<programlisting>import sferes

def build(bld):
  uselib_ = 'EIGEN2 GSL BOOST_UNIT_TEST_FRAMEWORK'
  cxxflags_kdtree = \
      bld.get_env()['CXXFLAGS']
  sferes.create_variants(bld,
                          source = 'test2.cpp',
                          uselib_local = 'sferes2',
                          uselib = uselib_,
                          target = '',
                          json = '',
                          cxxflags=cxxflags_kdtree,
                          variants = ['DNN','DNN FEEDF'])

</programlisting>
      </para>
      <para>
        The important part of this code is the variants which define the variants
        of the binary to compile. The first flag is generic (you need at least one
        flag to compile a binary) and the second one, FEEDF, will create a variant
        which has a #define FF at the beginning of the file (do not use FF as it
        is already defined in BOOST code).
      </para>
      <para>
        we can then modify the include to add the gen_dnn_ff.hpp genotype instead
        of the previous gen_dnn.hpp if FF is defined:
      </para>
      <para>
<programlisting><phrase role="preprocessor">#ifdef</phrase> <phrase role="identifier">FEEDF</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">modules</phrase><phrase role="special">/</phrase><phrase role="identifier">nn2</phrase><phrase role="special">/</phrase><phrase role="identifier">gen_dnn_ff</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#else</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">modules</phrase><phrase role="special">/</phrase><phrase role="identifier">nn2</phrase><phrase role="special">/</phrase><phrase role="identifier">gen_dnn</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#endif</phrase>
</programlisting>
      </para>
      <para>
        The next step is to change the network template parameters to use feedforward
        networks:
      </para>
      <para>
<programlisting><phrase role="preprocessor">#ifdef</phrase> <phrase role="identifier">FEEDF</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">DnnFF</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">neuron_t</phrase><phrase role="special">,</phrase>  <phrase role="identifier">connection_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">gen_t</phrase><phrase role="special">;</phrase>
<phrase role="preprocessor">#else</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">Dnn</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">neuron_t</phrase><phrase role="special">,</phrase>  <phrase role="identifier">connection_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">gen_t</phrase><phrase role="special">;</phrase>
<phrase role="preprocessor">#endif</phrase>
</programlisting>
      </para>
      <para>
        The next necessary step is to define the initial topology as a feedforward
        simple network, as a random topology may be recursive:
      </para>
      <para>
<programlisting><phrase role="preprocessor">#ifdef</phrase> <phrase role="identifier">FEEDF</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">init_t</phrase> <phrase role="identifier">init</phrase> <phrase role="special">=</phrase> <phrase role="identifier">ff</phrase><phrase role="special">;</phrase>
<phrase role="preprocessor">#else</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">init_t</phrase> <phrase role="identifier">init</phrase> <phrase role="special">=</phrase> <phrase role="identifier">random_topology</phrase><phrase role="special">;</phrase>
<phrase role="preprocessor">#endif</phrase>
</programlisting>
      </para>
      <para>
        As a bonus, if you use the DnnFF instead of Dnn, the number of steps required
        before convergence of the network is equal to the network's depth, which
        can be computed by the get_depth function.
      </para>
      <para>
<programlisting><phrase role="identifier">ifdef</phrase> <phrase role="identifier">FEEDF</phrase>
  <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_iterations</phrase> <phrase role="special">=</phrase> <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">gen</phrase><phrase role="special">().</phrase><phrase role="identifier">get_depth</phrase><phrase role="special">();</phrase>
<phrase role="preprocessor">#else</phrase>
  <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_iterations</phrase> <phrase role="special">=</phrase> <phrase role="number">5</phrase><phrase role="special">;</phrase>
<phrase role="preprocessor">#endif</phrase>
</programlisting>
      </para>
      <para>
        the compilation should the provide you with two binary files :
      </para>
      <para>
<programlisting>test2_dnn
test2_dnn_feedf
</programlisting>
      </para>
    </section>
    <section id="documentation.tutorial_topo.complete_source_code_for_the_experiment">
      <title><link linkend="documentation.tutorial_topo.complete_source_code_for_the_experiment">Complete
      source code for the experiment</link></title>
      <para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">phen</phrase><phrase role="special">/</phrase><phrase role="identifier">parameters</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">gen</phrase><phrase role="special">/</phrase><phrase role="identifier">evo_float</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">ea</phrase><phrase role="special">/</phrase><phrase role="identifier">rank_simple</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">eval</phrase><phrase role="special">/</phrase><phrase role="identifier">eval</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">stat</phrase><phrase role="special">/</phrase><phrase role="identifier">best_fit</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">stat</phrase><phrase role="special">/</phrase><phrase role="identifier">mean_fit</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">modif</phrase><phrase role="special">/</phrase><phrase role="identifier">dummy</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">run</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>


<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">modules</phrase><phrase role="special">/</phrase><phrase role="identifier">nn2</phrase><phrase role="special">/</phrase><phrase role="identifier">gen_dnn</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="preprocessor">#ifdef</phrase> <phrase role="identifier">FEEDF</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">modules</phrase><phrase role="special">/</phrase><phrase role="identifier">nn2</phrase><phrase role="special">/</phrase><phrase role="identifier">gen_dnn_ff</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#endif</phrase>

<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">modules</phrase><phrase role="special">/</phrase><phrase role="identifier">nn2</phrase><phrase role="special">/</phrase><phrase role="identifier">phen_dnn</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">;</phrase>
<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">evo_float</phrase><phrase role="special">;</phrase>
<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">dnn</phrase><phrase role="special">;</phrase>
<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">nn</phrase><phrase role="special">;</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">Params</phrase>
<phrase role="special">{</phrase>
 <phrase role="keyword">struct</phrase> <phrase role="identifier">evo_float</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">mutation_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">cross_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">mutation_t</phrase> <phrase role="identifier">mutation_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">polynomial</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">cross_over_t</phrase> <phrase role="identifier">cross_over_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">sbx</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_m</phrase> <phrase role="special">=</phrase> <phrase role="number">15.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_c</phrase> <phrase role="special">=</phrase> <phrase role="number">15.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">dnn</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_inputs</phrase> <phrase role="special">=</phrase> <phrase role="number">2</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_outputs</phrase>  <phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">min_nb_neurons</phrase>  <phrase role="special">=</phrase> <phrase role="number">3</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_nb_neurons</phrase>  <phrase role="special">=</phrase> <phrase role="number">8</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">min_nb_conns</phrase>  <phrase role="special">=</phrase> <phrase role="number">100</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_nb_conns</phrase>  <phrase role="special">=</phrase> <phrase role="number">101</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_add_conn</phrase>  <phrase role="special">=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_del_conn</phrase>  <phrase role="special">=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_change_conn</phrase> <phrase role="special">=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_add_neuron</phrase>  <phrase role="special">=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_del_neuron</phrase>  <phrase role="special">=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">io_param_evolving</phrase> <phrase role="special">=</phrase> <phrase role="keyword">true</phrase><phrase role="special">;</phrase>
<phrase role="preprocessor">#ifdef</phrase> <phrase role="identifier">FEEDF</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">init_t</phrase> <phrase role="identifier">init</phrase> <phrase role="special">=</phrase> <phrase role="identifier">ff</phrase><phrase role="special">;</phrase>
<phrase role="preprocessor">#else</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">init_t</phrase> <phrase role="identifier">init</phrase> <phrase role="special">=</phrase> <phrase role="identifier">random_topology</phrase><phrase role="special">;</phrase>
<phrase role="preprocessor">#endif</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">pop</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="identifier">size</phrase> <phrase role="special">=</phrase> <phrase role="number">200</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="identifier">nb_gen</phrase> <phrase role="special">=</phrase> <phrase role="number">2000</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">dump_period</phrase> <phrase role="special">=</phrase> <phrase role="number">5</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">initial_aleat</phrase> <phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">coeff</phrase> <phrase role="special">=</phrase> <phrase role="number">1.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">keep_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.6f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">parameters</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">min</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="number">5.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">max</phrase> <phrase role="special">=</phrase> <phrase role="number">5.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">fit</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_hidden_neurons</phrase> <phrase role="special">=</phrase> <phrase role="number">3</phrase> <phrase role="special">;</phrase>
    <phrase role="identifier">SFERES_ARRAY</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase><phrase role="special">,</phrase><phrase role="identifier">x_pos</phrase><phrase role="special">,</phrase> <phrase role="number">0.69</phrase><phrase role="special">,</phrase> <phrase role="number">0.52</phrase><phrase role="special">,</phrase> <phrase role="number">0.80</phrase><phrase role="special">,</phrase> <phrase role="number">0.95</phrase><phrase role="special">,</phrase> <phrase role="number">0.97</phrase><phrase role="special">,</phrase> <phrase role="number">0.82</phrase><phrase role="special">,</phrase> <phrase role="number">0.11</phrase><phrase role="special">,</phrase> <phrase role="number">0.13</phrase><phrase role="special">,</phrase> <phrase role="number">0.27</phrase><phrase role="special">,</phrase> <phrase role="number">0.59</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">SFERES_ARRAY</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase><phrase role="special">,</phrase><phrase role="identifier">y_pos</phrase><phrase role="special">,</phrase> <phrase role="number">0.24</phrase><phrase role="special">,</phrase> <phrase role="number">0.30</phrase><phrase role="special">,</phrase> <phrase role="number">0.63</phrase><phrase role="special">,</phrase> <phrase role="number">0.30</phrase><phrase role="special">,</phrase> <phrase role="number">0.81</phrase><phrase role="special">,</phrase> <phrase role="number">0.50</phrase><phrase role="special">,</phrase> <phrase role="number">0.47</phrase><phrase role="special">,</phrase> <phrase role="number">0.53</phrase><phrase role="special">,</phrase> <phrase role="number">0.51</phrase><phrase role="special">,</phrase> <phrase role="number">0.66</phrase><phrase role="special">);</phrase>
  <phrase role="special">};</phrase>

<phrase role="special">};</phrase>

<phrase role="identifier">SFERES_FITNESS</phrase><phrase role="special">(</phrase><phrase role="identifier">FitTest</phrase><phrase role="special">,</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">Fitness</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
 <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
  <phrase role="comment">// indiv will have the type defined in the main (phen_t)</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="identifier">Indiv</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">ind</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">//initialize network (set weights and parameters, reset accumulators and set the weight buffers if pf)</phrase>
    <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">develop</phrase><phrase role="special">();</phrase>
    <phrase role="keyword">float</phrase> <phrase role="identifier">v</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">float</phrase> <phrase role="identifier">tmp_val</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
<phrase role="preprocessor">#ifdef</phrase> <phrase role="identifier">FEEDF</phrase>
    <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_iterations</phrase> <phrase role="special">=</phrase> <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">gen</phrase><phrase role="special">().</phrase><phrase role="identifier">get_depth</phrase><phrase role="special">();</phrase>
<phrase role="preprocessor">#else</phrase>
    <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_iterations</phrase> <phrase role="special">=</phrase> <phrase role="number">5</phrase><phrase role="special">;</phrase>
<phrase role="preprocessor">#endif</phrase>
    <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">x_pos_size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">j</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">j</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">y_pos_size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">j</phrase><phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
        <phrase role="comment">//set the network inputs</phrase>
        <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">float</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">inputs</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">);</phrase>
        <phrase role="identifier">inputs</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">x_pos</phrase><phrase role="special">(</phrase><phrase role="identifier">i</phrase><phrase role="special">));</phrase>
        <phrase role="identifier">inputs</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">y_pos</phrase><phrase role="special">(</phrase><phrase role="identifier">j</phrase><phrase role="special">));</phrase>
        <phrase role="comment">//iterate the network 5 times (if the network is recurrent, additionnal tests could be necessary to test the stability)</phrase>
        <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">k</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">k</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">max_iterations</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">k</phrase><phrase role="special">)</phrase>
        <phrase role="special">{</phrase>
          <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">step</phrase><phrase role="special">(</phrase><phrase role="identifier">inputs</phrase><phrase role="special">);</phrase>
        <phrase role="special">}</phrase>
        <phrase role="identifier">tmp_val</phrase><phrase role="special">=(</phrase><phrase role="identifier">_gaussian</phrase><phrase role="special">(</phrase><phrase role="identifier">inputs</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">],</phrase><phrase role="identifier">inputs</phrase><phrase role="special">[</phrase><phrase role="number">1</phrase><phrase role="special">])-</phrase><phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">get_outf</phrase><phrase role="special">()[</phrase><phrase role="number">0</phrase><phrase role="special">]);</phrase>
        <phrase role="identifier">v</phrase><phrase role="special">+=</phrase><phrase role="identifier">tmp_val</phrase><phrase role="special">*</phrase><phrase role="identifier">tmp_val</phrase><phrase role="special">;</phrase>
      <phrase role="special">}</phrase>
    <phrase role="special">}</phrase>
    <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">mode</phrase><phrase role="special">()</phrase> <phrase role="special">==</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">mode</phrase><phrase role="special">::</phrase><phrase role="identifier">view</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ofstream</phrase> <phrase role="identifier">ofs</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">(</phrase><phrase role="string">&quot;graph.dot&quot;</phrase><phrase role="special">).</phrase><phrase role="identifier">c_str</phrase><phrase role="special">());</phrase>
      <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">write</phrase><phrase role="special">(</phrase><phrase role="identifier">ofs</phrase><phrase role="special">);</phrase>
    <phrase role="special">}</phrase>
    <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_value</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="identifier">v</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
 <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
  <phrase role="keyword">float</phrase> <phrase role="identifier">_gaussian</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase> <phrase role="identifier">x</phrase><phrase role="special">,</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">y</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">return</phrase> <phrase role="identifier">exp</phrase><phrase role="special">(-(</phrase><phrase role="identifier">x</phrase><phrase role="special">*</phrase><phrase role="identifier">x</phrase><phrase role="special">+</phrase><phrase role="identifier">y</phrase><phrase role="special">*</phrase><phrase role="identifier">y</phrase><phrase role="special">)/</phrase><phrase role="number">2</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase>

<phrase role="special">};</phrase>



<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">argc</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="special">**</phrase><phrase role="identifier">argv</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">Parameters</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoFloat</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">FitDummy</phrase><phrase role="special">&lt;&gt;,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">weight_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">Parameters</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoFloat</phrase><phrase role="special">&lt;</phrase><phrase role="number">1</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">FitDummy</phrase><phrase role="special">&lt;&gt;,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">bias_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">PfWSum</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">weight_t</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">pf_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">AfTanh</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">bias_t</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">af_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">Neuron</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">pf_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">af_t</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">neuron_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">Connection</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">weight_t</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">connection_t</phrase><phrase role="special">;</phrase>

<phrase role="preprocessor">#ifdef</phrase> <phrase role="identifier">FEEDF</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">DnnFF</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">neuron_t</phrase><phrase role="special">,</phrase>  <phrase role="identifier">connection_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">gen_t</phrase><phrase role="special">;</phrase>
<phrase role="preprocessor">#else</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">Dnn</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">neuron_t</phrase><phrase role="special">,</phrase>  <phrase role="identifier">connection_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">gen_t</phrase><phrase role="special">;</phrase>
<phrase role="preprocessor">#endif</phrase>

  <phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">Dnn</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">FitTest</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">phen_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">eval</phrase><phrase role="special">::</phrase><phrase role="identifier">Parallel</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">fusion</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">stat</phrase><phrase role="special">::</phrase><phrase role="identifier">BestFit</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">stat</phrase><phrase role="special">::</phrase><phrase role="identifier">MeanFit</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>  <phrase role="identifier">stat_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">modif</phrase><phrase role="special">::</phrase><phrase role="identifier">Dummy</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="identifier">modifier_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">ea</phrase><phrase role="special">::</phrase><phrase role="identifier">RankSimple</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">stat_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">modifier_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">ea_t</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">ea_t</phrase> <phrase role="identifier">ea</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">run_ea</phrase><phrase role="special">(</phrase><phrase role="identifier">argc</phrase><phrase role="special">,</phrase> <phrase role="identifier">argv</phrase><phrase role="special">,</phrase> <phrase role="identifier">ea</phrase><phrase role="special">);</phrase>
  <phrase role="comment">//</phrase>
  <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      </para>
    </section>
  </section>
  <section id="documentation.tutorial_evoneuro">
    <title><link linkend="documentation.tutorial_evoneuro">Neurobiology Tutorial
    III</link></title>
    <para>
      This third tutorial will guide you through the process of evolving the topology
      and parameters of maps, using the evoneuro module. We will test both the evolution
      of parameters first and then the evolution of a complete topology.
    </para>
    <para>
      This tutorial will evolve networks to solve the task taken from neurosciences.
      With inputs corresponding to possible actions, the network must select the
      output corresponding to the maximum input and have a minimal output on this
      node. On the contrary, all the other outputs must be maximized. This a task
      similar to a winner-takes-all, but where the winner has a minimal output and
      losers have a maximal output.
    </para>
    <para>
      Disclaimer : If you do not intend to evolve the topology of the network, you
      might instead use the first tutorial to create by hand any fixed network topology
      instead of learning to use this tool. The main advantage of the EvoNeuro module
      is the automatic generation of neural maps and its ability to evolve them.
    </para>
    <section id="documentation.tutorial_evoneuro.presentation_of_the_evoneuro_module">
      <title><link linkend="documentation.tutorial_evoneuro.presentation_of_the_evoneuro_module">Presentation
      of the EvoNeuro module</link></title>
      <para>
        The evoneuro module in sferes is composed of both a genotype and a phenotype
        class. The genotype class evolves a dnn network similar to the one used in
        dnn (appart from some additionnal evolvable parameters in each node and connection).
        The topology, weights and parameters can be evolved as in a standard neural
        network.
      </para>
      <para>
        The specificity of the EvoNeuro module comes from the phenotype class: it
        creates a new network of neuron maps from the topology of the genotype network.
        During the develop() function (viewed in the <link linkend="documentation.tutorial_topo.add_headers">second
        tutorial</link>) each neurons from the genotype can be transformed into:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            a map of neurons with similar properties as the original neuron;
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            a single neuron (no transformation).
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        This depends on an evolved parameter for each neuron. Each connection is
        similarly transformed into:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            a one-to-all connectivity pattern (if either the pre- and/or post-synaptic
            node is a single neuron, this is the only possibility);
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            a on-to-one connectivity pattern between two maps;
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            a on-to-all connectivity pattern between two mapos with gaussian weights
            (the connection between corresponding elements is at the maximum weights
            and the weights gets smaller when the index difference increases).
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        The development process is shown in the following figure.
      </para>
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../img/evoneuro.png"></imagedata></imageobject>
        <textobject>
          <phrase>evoneuro</phrase>
        </textobject>
        </inlinemediaobject>
      </para>
    </section>
    <section id="documentation.tutorial_evoneuro.creating_a_new_experiment_which_uses_the_evoneuro_module">
      <title><link linkend="documentation.tutorial_evoneuro.creating_a_new_experiment_which_uses_the_evoneuro_module">Creating
      a new experiment which uses the evoneuro module</link></title>
      <para>
        Like previously, we are going to start from the sample experiment we used
        previously. The first thing to modify is the params. We need to declare the
        parameters for dnn (used by evoneuro) and evoneuro itself:
      </para>
      <para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">dnn</phrase>
 <phrase role="special">{</phrase>
   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_inputs</phrase> <phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_outputs</phrase>  <phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>

   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">min_nb_neurons</phrase>	<phrase role="special">=</phrase> <phrase role="number">3</phrase><phrase role="special">;</phrase>
   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_nb_neurons</phrase>	<phrase role="special">=</phrase> <phrase role="number">8</phrase><phrase role="special">;</phrase>
   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">min_nb_conns</phrase>	<phrase role="special">=</phrase> <phrase role="number">2</phrase><phrase role="special">;</phrase>
   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_nb_conns</phrase>	<phrase role="special">=</phrase> <phrase role="number">15</phrase><phrase role="special">;</phrase>

   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_add_conn</phrase>	<phrase role="special">=</phrase> <phrase role="number">0.05f</phrase><phrase role="special">;</phrase>
   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_del_conn</phrase>	<phrase role="special">=</phrase> <phrase role="number">0.03f</phrase><phrase role="special">;</phrase>
   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_change_conn</phrase> <phrase role="special">=</phrase> <phrase role="number">0.07f</phrase><phrase role="special">;</phrase>
   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_add_neuron</phrase>  <phrase role="special">=</phrase> <phrase role="number">0.02f</phrase><phrase role="special">;</phrase>
   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_del_neuron</phrase>  <phrase role="special">=</phrase> <phrase role="number">0.01f</phrase><phrase role="special">;</phrase>

   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">io_param_evolving</phrase>  <phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>

   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">init_t</phrase> <phrase role="identifier">init</phrase> <phrase role="special">=</phrase> <phrase role="identifier">random_topology</phrase><phrase role="special">;</phrase>
 <phrase role="special">};</phrase>
 <phrase role="keyword">struct</phrase> <phrase role="identifier">evo_neuro</phrase>
 <phrase role="special">{</phrase>
   <phrase role="keyword">typedef</phrase> <phrase role="identifier">nn</phrase><phrase role="special">::</phrase><phrase role="identifier">Neuron</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nn</phrase><phrase role="special">::</phrase><phrase role="identifier">PfWSum</phrase><phrase role="special">&lt;&gt;,</phrase> <phrase role="identifier">nn</phrase><phrase role="special">::</phrase><phrase role="identifier">AfLpds</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="special">&gt;</phrase>  <phrase role="identifier">neuron_t</phrase><phrase role="special">;</phrase>
   <phrase role="keyword">typedef</phrase> <phrase role="identifier">nn</phrase><phrase role="special">::</phrase><phrase role="identifier">Connection</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="identifier">connection_t</phrase><phrase role="special">;</phrase>
   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">map_size</phrase>  <phrase role="special">=</phrase> <phrase role="number">5</phrase><phrase role="special">;</phrase>
   <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase>  <phrase role="identifier">max_weight</phrase>  <phrase role="special">=</phrase> <phrase role="number">5.0f</phrase><phrase role="special">;</phrase>
 <phrase role="special">};</phrase>
</programlisting>
      </para>
      <para>
        First, nb_inputs and nb_outputs are set to one, as there are usually a single
        input and a single output map. The maximum and minimum values of neurons
        and connections will only apply to the genotype graph and not to the developped
        network.
      </para>
      <para>
        The evo_neuro struct contains the type of neurons and connections that will
        be used by the develop() function to create the phenotype network as they
        are different from the genotype one (contrary to dnn). For the sake of simplicity,
        we will keep the AfLpds function used which is a neuron with internal variables.
        However, you can easily modify the phen_evoneuro.hpp file to use other types
        of neurons.
      </para>
      <para>
        We must then define the typedefs for our network in the main function:
      </para>
      <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">Parameters</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoFloat</phrase><phrase role="special">&lt;</phrase><phrase role="number">4</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">FitDummy</phrase><phrase role="special">&lt;&gt;,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">node_label_t</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">Parameters</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoFloat</phrase><phrase role="special">&lt;</phrase><phrase role="number">3</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">FitDummy</phrase><phrase role="special">&lt;&gt;,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">conn_label_t</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoNeuro</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">node_label_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">conn_label_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">gen_t</phrase><phrase role="special">;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoNeuro</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">FitTest</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">phen_t</phrase><phrase role="special">;</phrase>
</programlisting>
      </para>
      <para>
        The first two lines are the nodes and connection types of neurons and connexions.
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            a node should contain the number of parameters for your af (your pf is
            considered to have no internal parameter) plus 1 parameter (defining
            if the node is a map or a single neuron)
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            a connection should contain 3 parameters:
            <itemizedlist>
              <listitem>
                <simpara>
                  one for the type of connection (1-1 or 1-all)
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  one for the weight pattern (constant or gaussian)
                </simpara>
              </listitem>
              <listitem>
                <simpara>
                  one for the weight of the connection
                </simpara>
              </listitem>
            </itemizedlist>
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        The two other lines are constant for use with evoneuro appart from the fitness
        definition
      </para>
    </section>
    <section id="documentation.tutorial_evoneuro.defining_an_adapted_fitness_function">
      <title><link linkend="documentation.tutorial_evoneuro.defining_an_adapted_fitness_function">Defining
      an adapted fitness function</link></title>
      <para>
        Contrary to the previous tutorial, the EvoNeuro module is ill-adapted to
        calculating a simple mathematical function. We instead try to emulate the
        results of the paper described in <ulink url="http://www.isir.upmc.fr/files/2010ACTI1526.pdf">this
        paper</ulink>. We want our network to evolve a contrast augmenting function
        : it should maximize the max from the incoming signals while reducing the
        value of other inputs channels in the output.
      </para>
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../img/contrast.png"></imagedata></imageobject>
        <textobject>
          <phrase>contrast</phrase>
        </textobject>
        </inlinemediaobject>
      </para>
    </section>
    <section id="documentation.tutorial_evoneuro.using_the_nsga_ii_algorithms_instead_of_simple_sorting">
      <title><link linkend="documentation.tutorial_evoneuro.using_the_nsga_ii_algorithms_instead_of_simple_sorting">Using
      the NSGA II algorithms instead of simple sorting</link></title>
      <para>
        As sferes2 provides NSGA2 (a multi-objective state of the art algorithm),
        we will optimize the two objectives separately.
      </para>
      <para>
        To change the evaluation algorithm, we just need to add the relevant headers.
        The first one is the evolutionary algorithm, the second one the statistics
        used to dump the fitness of the individuals on the pareto front.
      </para>
      <para>
<programlisting><phrase role="comment">//#include &lt;sferes/ea/rank_simple.hpp&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">ea</phrase><phrase role="special">/</phrase><phrase role="identifier">nsga2</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="comment">//#include &lt;sferes/stat/best_fit.hpp&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">stat</phrase><phrase role="special">/</phrase><phrase role="identifier">pareto_front</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

</programlisting>
      </para>
      <para>
        We also need to change the corresponding typedefs in the main function:
      </para>
      <para>
<programlisting><phrase role="comment">//typedef boost::fusion::vector&lt;stat::BestFit&lt;phen_t, Params&gt;, stat::MeanFit&lt;Params&gt; &gt;  stat_t;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">fusion</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">stat</phrase><phrase role="special">::</phrase><phrase role="identifier">ParetoFront</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">stat</phrase><phrase role="special">::</phrase><phrase role="identifier">MeanFit</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>  <phrase role="identifier">stat_t</phrase><phrase role="special">;</phrase>
<phrase role="comment">//typedef ea::RankSimple2&lt;phen_t, eval_t, stat_t, modifier_t, Params&gt; ea_t;</phrase>
<phrase role="keyword">typedef</phrase> <phrase role="identifier">ea</phrase><phrase role="special">::</phrase><phrase role="identifier">Nsga2</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">stat_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">modifier_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">ea_t</phrase><phrase role="special">;</phrase>

</programlisting>
      </para>
      <para>
        The next step is to initialize the objective vector at the beginning of our
        eval function (NSGA II uses a vector of objectives instead of a single value):
      </para>
      <para>
<programlisting><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">.</phrase><phrase role="identifier">resize</phrase><phrase role="special">(</phrase><phrase role="number">2</phrase><phrase role="special">);</phrase>
<phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">i</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
  <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">[</phrase><phrase role="identifier">i</phrase><phrase role="special">]=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase>
</programlisting>
      </para>
    </section>
    <section id="documentation.tutorial_evoneuro.defining_the_random_inputs_sets">
      <title><link linkend="documentation.tutorial_evoneuro.defining_the_random_inputs_sets">Defining
      the random inputs sets</link></title>
      <para>
        The evaluation function will need to test the different networks on a set
        of random inputs, and, for each set, have only the output corresponding to
        the maximum input at zero, while the other outputs are maxed out. This can
        be easily done throught two objectives:
      </para>
      <itemizedlist>
        <listitem>
          <simpara>
            minimize the output corresponding to the max input
          </simpara>
        </listitem>
        <listitem>
          <simpara>
            maximize the sum of the other outputs
          </simpara>
        </listitem>
      </itemizedlist>
      <para>
        The first step is therefore to create random inputs sets in the fitness function.
        These sets are created here as a vector of vector of floats with values between
        0 and 1. The sets are created at the initialisation of the FitTest function.
      </para>
      <para>
<programlisting><phrase role="keyword">public</phrase><phrase role="special">:</phrase>
  <phrase role="identifier">FitTest</phrase><phrase role="special">():</phrase>
    <phrase role="identifier">inputs_list</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
   <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">test</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">test</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">nb_tests</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">test</phrase> <phrase role="special">)</phrase>
   <phrase role="special">{</phrase>
     <phrase role="identifier">inputs_list</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">float</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">evo_neuro</phrase><phrase role="special">::</phrase><phrase role="identifier">map_size</phrase><phrase role="special">));</phrase>
     <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">inputs_list</phrase><phrase role="special">.</phrase><phrase role="identifier">back</phrase><phrase role="special">().</phrase><phrase role="identifier">size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase> <phrase role="special">)</phrase>
     <phrase role="special">{</phrase>
       <phrase role="identifier">inputs_list</phrase><phrase role="special">.</phrase><phrase role="identifier">back</phrase><phrase role="special">()[</phrase><phrase role="identifier">i</phrase><phrase role="special">]</phrase> <phrase role="special">=</phrase> <phrase role="identifier">misc</phrase><phrase role="special">::</phrase><phrase role="identifier">rand</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">float</phrase><phrase role="special">&gt;();</phrase>
     <phrase role="special">}</phrase>
   <phrase role="special">}</phrase>
  <phrase role="special">}</phrase>
</programlisting>
      </para>
      <para>
        and
      </para>
      <para>
<programlisting><phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">float</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">inputs_list</phrase><phrase role="special">;</phrase>
</programlisting>
      </para>
    </section>
    <section id="documentation.tutorial_evoneuro.defining_the_eval_function">
      <title><link linkend="documentation.tutorial_evoneuro.defining_the_eval_function">Defining
      the eval function</link></title>
      <para>
        We are going to use the following eval function:
      </para>
      <para>
<programlisting><phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="identifier">Indiv</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">ind</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="comment">// resize the objective vector</phrase>
  <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">.</phrase><phrase role="identifier">resize</phrase><phrase role="special">(</phrase><phrase role="number">2</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">i</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
    <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">[</phrase><phrase role="identifier">i</phrase><phrase role="special">]=</phrase><phrase role="number">0.0f</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// generate the phenotype network</phrase>
  <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">develop</phrase><phrase role="special">();</phrase>
  <phrase role="comment">// if we are looking at the results, dump the genotype topology to graph.dot</phrase>
  <phrase role="comment">// the simplify function remove all non-useful parts</phrase>
  <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">mode</phrase><phrase role="special">()</phrase> <phrase role="special">==</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">mode</phrase><phrase role="special">::</phrase><phrase role="identifier">view</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ofstream</phrase> <phrase role="identifier">ofs</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">(</phrase><phrase role="string">&quot;graph.dot&quot;</phrase><phrase role="special">).</phrase><phrase role="identifier">c_str</phrase><phrase role="special">());</phrase>
    <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">gen</phrase><phrase role="special">().</phrase><phrase role="identifier">simplify</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">gen</phrase><phrase role="special">().</phrase><phrase role="identifier">name_io</phrase><phrase role="special">();</phrase>
    <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">gen</phrase><phrase role="special">().</phrase><phrase role="identifier">write</phrase><phrase role="special">(</phrase><phrase role="identifier">ofs</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase>
  <phrase role="comment">// initialise the phenotype network </phrase>
  <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">init</phrase><phrase role="special">();</phrase>
  <phrase role="comment">// test all the possible input sets</phrase>
  <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">test</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">test</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">nb_tests</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">test</phrase> <phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">//find the maximum input in the set</phrase>
    <phrase role="identifier">size_t</phrase> <phrase role="identifier">max</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">inputs_list</phrase><phrase role="special">[</phrase><phrase role="identifier">test</phrase><phrase role="special">].</phrase><phrase role="identifier">size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase> <phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">inputs_list</phrase><phrase role="special">[</phrase><phrase role="identifier">test</phrase><phrase role="special">][</phrase><phrase role="identifier">i</phrase><phrase role="special">]</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">inputs_list</phrase><phrase role="special">[</phrase><phrase role="identifier">test</phrase><phrase role="special">][</phrase><phrase role="identifier">max</phrase><phrase role="special">])</phrase>
        <phrase role="identifier">max</phrase> <phrase role="special">=</phrase> <phrase role="identifier">i</phrase><phrase role="special">;</phrase>
    <phrase role="special">}</phrase>
    <phrase role="comment">//loop the network </phrase>
    <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">cycles</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">cycles</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">max_cycles</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">cycles</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">step</phrase><phrase role="special">(</phrase><phrase role="identifier">inputs_list</phrase><phrase role="special">[</phrase><phrase role="identifier">test</phrase><phrase role="special">]);</phrase>
    <phrase role="special">}</phrase>
    <phrase role="comment">//set the first objective (minimise output with the same index as the maximal input)</phrase>
    <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">]</phrase> <phrase role="special">+=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">-</phrase><phrase role="identifier">fabs</phrase><phrase role="special">(</phrase><phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">get_outf</phrase><phrase role="special">()[</phrase><phrase role="identifier">max</phrase><phrase role="special">]);</phrase>
    <phrase role="comment">//set the second objective as the average value of other outputs</phrase>
    <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">get_outf</phrase><phrase role="special">().</phrase><phrase role="identifier">size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase> <phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">i</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">max</phrase><phrase role="special">)</phrase>
        <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">[</phrase><phrase role="number">1</phrase><phrase role="special">]</phrase> <phrase role="special">+=</phrase> <phrase role="identifier">fabs</phrase><phrase role="special">(</phrase><phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">get_outf</phrase><phrase role="special">()[</phrase><phrase role="identifier">i</phrase><phrase role="special">])/(</phrase><phrase role="keyword">float</phrase><phrase role="special">)(</phrase><phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">get_outf</phrase><phrase role="special">().</phrase><phrase role="identifier">size</phrase><phrase role="special">()-</phrase><phrase role="number">1.0f</phrase><phrase role="special">);</phrase>
    <phrase role="special">}</phrase>
  <phrase role="special">}</phrase>
  <phrase role="comment">//average the objectives with the number of tests</phrase>
  <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">i</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
    <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">[</phrase><phrase role="identifier">i</phrase><phrase role="special">]/=(</phrase><phrase role="keyword">float</phrase><phrase role="special">)(</phrase><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">nb_tests</phrase><phrase role="special">);</phrase>
<phrase role="special">}</phrase>
</programlisting>
      </para>
    </section>
    <section id="documentation.tutorial_evoneuro.sample_solution_network">
      <title><link linkend="documentation.tutorial_evoneuro.sample_solution_network">Sample
      solution network</link></title>
      <para>
        If you launch an experiment with this code, you should find networks like
        the following graph (the maps have not been developped):
      </para>
      <para>
        <inlinemediaobject><imageobject><imagedata fileref="../img/graph.png"></imagedata></imageobject>
        <textobject>
          <phrase>graph</phrase>
        </textobject>
        </inlinemediaobject>
      </para>
    </section>
    <section id="documentation.tutorial_evoneuro.analysing_the_results">
      <title><link linkend="documentation.tutorial_evoneuro.analysing_the_results">Analysing
      the results</link></title>
      <para>
        After compiling the code and executing the code, you can analyse the results
        by browsing the pareto.dat file or launching the runs with the load command.
      </para>
    </section>
    <section id="documentation.tutorial_evoneuro.complete_source_code">
      <title><link linkend="documentation.tutorial_evoneuro.complete_source_code">Complete
      source code</link></title>
      <para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">iostream</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">phen</phrase><phrase role="special">/</phrase><phrase role="identifier">parameters</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">gen</phrase><phrase role="special">/</phrase><phrase role="identifier">evo_float</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">eval</phrase><phrase role="special">/</phrase><phrase role="identifier">eval</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">ea</phrase><phrase role="special">/</phrase><phrase role="identifier">nsga2</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="comment">//#include &lt;sferes/stat/best_fit.hpp&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">stat</phrase><phrase role="special">/</phrase><phrase role="identifier">pareto_front</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">stat</phrase><phrase role="special">/</phrase><phrase role="identifier">mean_fit</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">modif</phrase><phrase role="special">/</phrase><phrase role="identifier">dummy</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">run</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">modules</phrase><phrase role="special">/</phrase><phrase role="identifier">evoneuro2</phrase><phrase role="special">/</phrase><phrase role="identifier">gen_evo_neuro</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="comment">//#include &quot;phen_evo_neuro.hpp&quot;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">modules</phrase><phrase role="special">/</phrase><phrase role="identifier">evoneuro2</phrase><phrase role="special">/</phrase><phrase role="identifier">phen_evo_neuro</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">modules</phrase><phrase role="special">/</phrase><phrase role="identifier">evoneuro2</phrase><phrase role="special">/</phrase><phrase role="identifier">lpds</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>

<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">;</phrase>
<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">evo_float</phrase><phrase role="special">;</phrase>
<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">dnn</phrase><phrase role="special">;</phrase>
<phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">nn</phrase><phrase role="special">;</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">Params</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">evo_float</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">mutation_t</phrase> <phrase role="identifier">mutation_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">polynomial</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">cross_over_t</phrase> <phrase role="identifier">cross_over_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">sbx</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">mutation_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">cross_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.5f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_m</phrase> <phrase role="special">=</phrase> <phrase role="number">15.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_c</phrase> <phrase role="special">=</phrase> <phrase role="number">10.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">pop</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="identifier">size</phrase> <phrase role="special">=</phrase> <phrase role="number">200</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="identifier">nb_gen</phrase> <phrase role="special">=</phrase> <phrase role="number">15000</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">dump_period</phrase> <phrase role="special">=</phrase> <phrase role="number">200</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">initial_aleat</phrase> <phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">coeff</phrase> <phrase role="special">=</phrase> <phrase role="number">1.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">keep_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.6f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">dnn</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_inputs</phrase>	<phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_outputs</phrase>	<phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">min_nb_neurons</phrase>	<phrase role="special">=</phrase> <phrase role="number">3</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_nb_neurons</phrase>	<phrase role="special">=</phrase> <phrase role="number">8</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">min_nb_conns</phrase>	<phrase role="special">=</phrase> <phrase role="number">2</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_nb_conns</phrase>	<phrase role="special">=</phrase> <phrase role="number">15</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_add_conn</phrase>	<phrase role="special">=</phrase> <phrase role="number">0.05f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_del_conn</phrase>	<phrase role="special">=</phrase> <phrase role="number">0.03f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_change_conn</phrase> <phrase role="special">=</phrase> <phrase role="number">0.07f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_add_neuron</phrase>  <phrase role="special">=</phrase> <phrase role="number">0.02f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">m_rate_del_neuron</phrase>  <phrase role="special">=</phrase> <phrase role="number">0.01f</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">io_param_evolving</phrase>  <phrase role="special">=</phrase> <phrase role="number">1</phrase><phrase role="special">;</phrase>

    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">init_t</phrase> <phrase role="identifier">init</phrase> <phrase role="special">=</phrase> <phrase role="identifier">random_topology</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">evo_neuro</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">nn</phrase><phrase role="special">::</phrase><phrase role="identifier">Neuron</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">nn</phrase><phrase role="special">::</phrase><phrase role="identifier">PfWSum</phrase><phrase role="special">&lt;&gt;,</phrase> <phrase role="identifier">nn</phrase><phrase role="special">::</phrase><phrase role="identifier">AfLpds</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="special">&gt;</phrase>  <phrase role="identifier">neuron_t</phrase><phrase role="special">;</phrase>
<phrase role="comment">//    typedef nn::Neuron&lt;nn::PfWSum&lt;&gt;, nn::AfTanh&lt;float&gt; &gt;  neuron_t;</phrase>
    <phrase role="keyword">typedef</phrase> <phrase role="identifier">nn</phrase><phrase role="special">::</phrase><phrase role="identifier">Connection</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="identifier">connection_t</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">map_size</phrase>	<phrase role="special">=</phrase> <phrase role="number">5</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase>  <phrase role="identifier">max_weight</phrase>	<phrase role="special">=</phrase> <phrase role="number">5.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>

  <phrase role="keyword">struct</phrase> <phrase role="identifier">parameters</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">min</phrase> <phrase role="special">=</phrase> <phrase role="number">0.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">max</phrase> <phrase role="special">=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">fit</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">max_cycles</phrase> <phrase role="special">=</phrase> <phrase role="number">200</phrase> <phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_tests</phrase> <phrase role="special">=</phrase> <phrase role="number">50</phrase> <phrase role="special">;</phrase>
  <phrase role="special">};</phrase>


<phrase role="special">};</phrase>

<phrase role="identifier">SFERES_FITNESS</phrase><phrase role="special">(</phrase><phrase role="identifier">FitTest</phrase><phrase role="special">,</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">Fitness</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
 <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
   <phrase role="identifier">FitTest</phrase><phrase role="special">():</phrase>
     <phrase role="identifier">inputs_list</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">)</phrase>
   <phrase role="special">{</phrase>
    <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">test</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">test</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">nb_tests</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">test</phrase> <phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="identifier">inputs_list</phrase><phrase role="special">.</phrase><phrase role="identifier">push_back</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">float</phrase><phrase role="special">&gt;(</phrase><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">evo_neuro</phrase><phrase role="special">::</phrase><phrase role="identifier">map_size</phrase><phrase role="special">));</phrase>
      <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">inputs_list</phrase><phrase role="special">.</phrase><phrase role="identifier">back</phrase><phrase role="special">().</phrase><phrase role="identifier">size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase> <phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
        <phrase role="identifier">inputs_list</phrase><phrase role="special">.</phrase><phrase role="identifier">back</phrase><phrase role="special">()[</phrase><phrase role="identifier">i</phrase><phrase role="special">]</phrase> <phrase role="special">=</phrase> <phrase role="identifier">misc</phrase><phrase role="special">::</phrase><phrase role="identifier">rand</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">float</phrase><phrase role="special">&gt;();</phrase>
      <phrase role="special">}</phrase>
    <phrase role="special">}</phrase>
   <phrase role="special">}</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="identifier">Indiv</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">ind</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="comment">// resize the objective vector</phrase>
    <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">.</phrase><phrase role="identifier">resize</phrase><phrase role="special">(</phrase><phrase role="number">2</phrase><phrase role="special">);</phrase>
    <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">i</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
      <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">[</phrase><phrase role="identifier">i</phrase><phrase role="special">]=</phrase><phrase role="number">0.0f</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">develop</phrase><phrase role="special">();</phrase>
    <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">mode</phrase><phrase role="special">()</phrase> <phrase role="special">==</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">mode</phrase><phrase role="special">::</phrase><phrase role="identifier">view</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ofstream</phrase> <phrase role="identifier">ofs</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">string</phrase><phrase role="special">(</phrase><phrase role="string">&quot;graph.dot&quot;</phrase><phrase role="special">).</phrase><phrase role="identifier">c_str</phrase><phrase role="special">());</phrase>
      <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">gen</phrase><phrase role="special">().</phrase><phrase role="identifier">simplify</phrase><phrase role="special">();</phrase>
      <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">gen</phrase><phrase role="special">().</phrase><phrase role="identifier">name_io</phrase><phrase role="special">();</phrase>
      <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">gen</phrase><phrase role="special">().</phrase><phrase role="identifier">write</phrase><phrase role="special">(</phrase><phrase role="identifier">ofs</phrase><phrase role="special">);</phrase>
    <phrase role="special">}</phrase>
    <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">init</phrase><phrase role="special">();</phrase>
    <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">test</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">test</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">nb_tests</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">test</phrase> <phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
      <phrase role="identifier">size_t</phrase> <phrase role="identifier">max</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
      <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">inputs_list</phrase><phrase role="special">[</phrase><phrase role="identifier">test</phrase><phrase role="special">].</phrase><phrase role="identifier">size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase> <phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
        <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">inputs_list</phrase><phrase role="special">[</phrase><phrase role="identifier">test</phrase><phrase role="special">][</phrase><phrase role="identifier">i</phrase><phrase role="special">]</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">inputs_list</phrase><phrase role="special">[</phrase><phrase role="identifier">test</phrase><phrase role="special">][</phrase><phrase role="identifier">max</phrase><phrase role="special">])</phrase>
          <phrase role="identifier">max</phrase> <phrase role="special">=</phrase> <phrase role="identifier">i</phrase><phrase role="special">;</phrase>
      <phrase role="special">}</phrase>
      <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">cycles</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">cycles</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">max_cycles</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">cycles</phrase><phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
        <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">step</phrase><phrase role="special">(</phrase><phrase role="identifier">inputs_list</phrase><phrase role="special">[</phrase><phrase role="identifier">test</phrase><phrase role="special">]);</phrase>
      <phrase role="special">}</phrase>
      <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">]</phrase> <phrase role="special">+=</phrase> <phrase role="number">1.0f</phrase><phrase role="special">-</phrase><phrase role="identifier">fabs</phrase><phrase role="special">(</phrase><phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">get_outf</phrase><phrase role="special">()[</phrase><phrase role="identifier">max</phrase><phrase role="special">]);</phrase>
      <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">get_outf</phrase><phrase role="special">().</phrase><phrase role="identifier">size</phrase><phrase role="special">();</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase> <phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
        <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">i</phrase> <phrase role="special">!=</phrase> <phrase role="identifier">max</phrase><phrase role="special">)</phrase>
          <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">[</phrase><phrase role="number">1</phrase><phrase role="special">]</phrase> <phrase role="special">+=</phrase> <phrase role="identifier">fabs</phrase><phrase role="special">(</phrase><phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">get_outf</phrase><phrase role="special">()[</phrase><phrase role="identifier">i</phrase><phrase role="special">])/(</phrase><phrase role="keyword">float</phrase><phrase role="special">)(</phrase><phrase role="identifier">ind</phrase><phrase role="special">.</phrase><phrase role="identifier">nn</phrase><phrase role="special">().</phrase><phrase role="identifier">get_outf</phrase><phrase role="special">().</phrase><phrase role="identifier">size</phrase><phrase role="special">()-</phrase><phrase role="number">1.0f</phrase><phrase role="special">);</phrase>
      <phrase role="special">}</phrase>
    <phrase role="special">}</phrase>
    <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase><phrase role="special">=</phrase><phrase role="number">0</phrase><phrase role="special">;</phrase><phrase role="identifier">i</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">.</phrase><phrase role="identifier">size</phrase><phrase role="special">();++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
      <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">[</phrase><phrase role="identifier">i</phrase><phrase role="special">]/=(</phrase><phrase role="keyword">float</phrase><phrase role="special">)(</phrase><phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">nb_tests</phrase><phrase role="special">);</phrase>
  <phrase role="special">}</phrase>
 <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase> <phrase role="keyword">float</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">inputs_list</phrase><phrase role="special">;</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">argc</phrase><phrase role="special">,</phrase> <phrase role="keyword">char</phrase> <phrase role="special">**</phrase><phrase role="identifier">argv</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">int</phrase> <phrase role="identifier">a</phrase><phrase role="special">(</phrase><phrase role="identifier">time</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">));</phrase>
  <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">argc</phrase><phrase role="special">&gt;</phrase><phrase role="number">1</phrase><phrase role="special">)</phrase>
    <phrase role="identifier">a</phrase><phrase role="special">=</phrase><phrase role="identifier">atoi</phrase><phrase role="special">(</phrase><phrase role="identifier">argv</phrase><phrase role="special">[</phrase><phrase role="number">1</phrase><phrase role="special">]);</phrase>
  <phrase role="identifier">srand</phrase><phrase role="special">(</phrase><phrase role="identifier">a</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">Parameters</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoFloat</phrase><phrase role="special">&lt;</phrase><phrase role="number">4</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">FitDummy</phrase><phrase role="special">&lt;&gt;,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">node_label_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">Parameters</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoFloat</phrase><phrase role="special">&lt;</phrase><phrase role="number">3</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">FitDummy</phrase><phrase role="special">&lt;&gt;,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">conn_label_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoNeuro</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">node_label_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">conn_label_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">gen_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">phen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoNeuro</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">FitTest</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">phen_t</phrase><phrase role="special">;</phrase>

  <phrase role="keyword">typedef</phrase> <phrase role="identifier">eval</phrase><phrase role="special">::</phrase><phrase role="identifier">Parallel</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">fusion</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">stat</phrase><phrase role="special">::</phrase><phrase role="identifier">ParetoFront</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">stat</phrase><phrase role="special">::</phrase><phrase role="identifier">MeanFit</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>  <phrase role="identifier">stat_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">modif</phrase><phrase role="special">::</phrase><phrase role="identifier">Dummy</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="identifier">modifier_t</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">typedef</phrase> <phrase role="identifier">ea</phrase><phrase role="special">::</phrase><phrase role="identifier">Nsga2</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">stat_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">modifier_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">ea_t</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">ea_t</phrase> <phrase role="identifier">ea</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">run_ea</phrase><phrase role="special">(</phrase><phrase role="identifier">argc</phrase><phrase role="special">,</phrase> <phrase role="identifier">argv</phrase><phrase role="special">,</phrase> <phrase role="identifier">ea</phrase><phrase role="special">);</phrase>
  <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase>
</programlisting>
      </para>
    </section>
  </section>
  <section id="documentation.reference">
    <title><link linkend="documentation.reference">Reference</link></title>
    <section id="documentation.reference.the_sferes2_framework">
      <title><link linkend="documentation.reference.the_sferes2_framework">The Sferes2
      framework</link></title>
      <section id="documentation.reference.the_sferes2_framework.main_concepts">
        <title><link linkend="documentation.reference.the_sferes2_framework.main_concepts">Main
        concepts</link></title>
        <section id="documentation.reference.the_sferes2_framework.main_concepts.static_object_oriented_paradigm">
          <title><link linkend="documentation.reference.the_sferes2_framework.main_concepts.static_object_oriented_paradigm">Static
          object-oriented paradigm</link></title>
          <para>
            Object-oriented programming (OOP) has many advantages which are desirable
            for complex high-level code. However, classic OOP (e.g. in C++) heavily
            relies on virtual methods to implement abstraction and polymorphism.
            Such an approach has a significant run-time overhead:
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                selecting the good method to call adds an indirection (the software
                have to check the virtual table)
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                abstract/virtual methods cannot be inlined, resulting in a overhead
                for very simple methods (e.g. setters/getters).
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
            In a few word, we want the main benefits of OOP (abstraction, re-usability)
            and the efficiency of low-level languages.
          </para>
          <para>
            One solution in C++ is to use the &quot;curiously recurring template
            pattern&quot; (<ulink url="http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern">http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern</ulink>[http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern]).
            Here is the idea:
          </para>
          <para>
<programlisting><phrase role="keyword">template</phrase> <phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Derived</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">struct</phrase> <phrase role="identifier">Base</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">interface</phrase><phrase role="special">()</phrase>
    <phrase role="special">{</phrase>
        <phrase role="keyword">static_cast</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Derived</phrase><phrase role="special">*&gt;(</phrase><phrase role="keyword">this</phrase><phrase role="special">)-&gt;</phrase><phrase role="identifier">implementation</phrase><phrase role="special">();</phrase>
    <phrase role="special">}</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">f</phrase><phrase role="special">()</phrase>
    <phrase role="special">{</phrase>
       <phrase role="keyword">for</phrase><phrase role="special">(</phrase><phrase role="keyword">int</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="number">3</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase> <phrase role="identifier">interface</phrase><phrase role="special">();</phrase>
    <phrase role="special">}</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">Derived</phrase> <phrase role="special">:</phrase> <phrase role="identifier">Base</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Derived</phrase><phrase role="special">&gt;</phrase>
<phrase role="special">{</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">implementation</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;impl&quot;</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
<phrase role="special">};</phrase></programlisting>
          </para>
          <para>
            This code mimics a virtual call of an abstract method: in the abstract
            class (Base), a generic algorithm can use methods which are only defined
            in the derived classes. Extending this pattern to draw a full hierarchy
            of classes requires more work; sferes2 relies on the method described
            in the following paper:
          </para>
          <para>
            Nicolas Burrus, Alexandre Duret-Lutz, Thierry Géraud, David Lesage and
            Raphaël Poss. A Static C++ Object-Oriented Programming (SCOOP) Paradigm
            Mixing Benefits of Traditional OOP and Generic Programming. In <emphasis>Proceedings
            of the Workshop on Multiple Paradigm with OO Languages (MPOOL'03)</emphasis>,
            2003. http://www.lrde.epita.fr/dload/papers/mpool03.pdf
          </para>
          <para>
            This mechanics is hidden in sferes2 behind some macros (see section [[macros]])
          </para>
        </section>
        <section id="documentation.reference.the_sferes2_framework.main_concepts.static_parameters">
          <title><link linkend="documentation.reference.the_sferes2_framework.main_concepts.static_parameters">Static
          parameters</link></title>
          <para>
            Evolutionary algorithms have a lot of parameters (e.g. population size,
            mutation rate, etc.) and we need a convenient way to set them. A configuration
            file (e.g. an XML file) is often used; however, such a method has two
            drawbacks:
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                some code to read the files has to be written and kept synchronized
                with the objects;
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                parameters are unknown at compile time so some checks (e.g. if (mutation_type
                = x) {} else { } ...) have to be done many times whereas they are
                useless.
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
            In sferes2, parameters are defined at compile time using a structure
            which contains only constants. This structure is passed to all sferes2
            classes so they can access to the parameters. This method allows to avoid
            to write read/write code for parameters. It also allows the compiler
            to propagate constants and settings in the whole source code, resulting
            in an executable optimized for the specific parameters.
          </para>
        </section>
        <section id="documentation.reference.the_sferes2_framework.main_concepts.macros_and_special_functions">
          <title><link linkend="documentation.reference.the_sferes2_framework.main_concepts.macros_and_special_functions">Macros
          and special functions</link></title>
          <orderedlist>
            <listitem>
              <simpara>
                &lt;&lt;macros&gt;&gt; To simplify the writing of &quot;static virtual
                functions&quot; and the definition of static parameters, sferes2
                provides several macros which are defined in [<ulink url="boost:../../sferes/stc.hpp">stc.hpp</ulink>]
                .
              </simpara>
            </listitem>
          </orderedlist>
        </section>
        <section id="documentation.reference.the_sferes2_framework.main_concepts.classes">
          <title><link linkend="documentation.reference.the_sferes2_framework.main_concepts.classes">Classes</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                SFERES_CLASS(Name): defines the base class Name ; this class uses
                the &quot;static&quot; inheritance scheme and takes a Param template
                parameter.
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                SFERES_CLASS_D(Name, Parent): derives the class Name from Parent
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                SFERES_PARENT(Name, Parent)::method(): calls method() in the parent
                class
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                stc::exact(this)-&gt;method(): calls an abstract method() which is
                defined in the derived classes
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
            Moreover, sferes2 provides special macros to define specific classes
            (SFERES_FITNESS, SFERES_INDIV, SFERES_EA, etc.). See <link linkend="documentation.reference.main_classes">ref</link>.
          </para>
          <para>
            Example:
          </para>
          <para>
<programlisting><phrase role="identifier">SFERES_CLASS</phrase><phrase role="special">(</phrase><phrase role="identifier">X</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">X</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;X&quot;</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">test</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="identifier">stc</phrase><phrase role="special">::</phrase><phrase role="identifier">exact</phrase><phrase role="special">(</phrase><phrase role="keyword">this</phrase><phrase role="special">)-&gt;</phrase><phrase role="identifier">blah</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">test2</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;test2&quot;</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
<phrase role="comment">// Y derives from X</phrase>
<phrase role="identifier">SFERES_CLASS_D</phrase><phrase role="special">(</phrase><phrase role="identifier">Y</phrase><phrase role="special">,</phrase> <phrase role="identifier">X</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">Y</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;Y&quot;</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">blah</phrase><phrase role="special">()</phrase>
  <phrase role="special">{</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;param::test::x&quot;</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">Param</phrase><phrase role="special">::</phrase><phrase role="identifier">test</phrase><phrase role="special">::</phrase><phrase role="identifier">x</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
    <phrase role="identifier">SFERES_PARENT</phrase><phrase role="special">(</phrase><phrase role="identifier">Y</phrase><phrase role="special">,</phrase> <phrase role="identifier">X</phrase><phrase role="special">)::</phrase><phrase role="identifier">test2</phrase><phrase role="special">();</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
<phrase role="comment">// Z derives from Y</phrase>
<phrase role="identifier">SFERES_CLASS_D</phrase><phrase role="special">(</phrase><phrase role="identifier">Z</phrase><phrase role="special">,</phrase> <phrase role="identifier">Y</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="identifier">Z</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;Z&quot;</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">blah</phrase><phrase role="special">()</phrase>
  <phrase role="special">{</phrase>
    <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">cout</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;Z&quot;</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
<phrase role="comment">// sample parameter (see next subsection)</phrase>
<phrase role="keyword">struct</phrase> <phrase role="identifier">Params_test</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">test</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
<phrase role="special">};</phrase>
<phrase role="comment">// to instantiate Y and Z (X is abstract):</phrase>
<phrase role="keyword">int</phrase> <phrase role="identifier">main</phrase><phrase role="special">()</phrase>
<phrase role="special">{</phrase>
  <phrase role="comment">// Y uses a parameter</phrase>
  <phrase role="identifier">Y</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Param_test</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">y</phrase><phrase role="special">;</phrase>
  <phrase role="comment">// Z doesn't use any parameter, these two forms are possible:</phrase>
  <phrase role="identifier">Z</phrase><phrase role="special">&lt;&gt;</phrase> <phrase role="identifier">z1</phrase><phrase role="special">;</phrase>
  <phrase role="identifier">Z</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Param_test</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">z2</phrase><phrase role="special">;</phrase>
  <phrase role="keyword">return</phrase> <phrase role="number">0</phrase><phrase role="special">;</phrase>
<phrase role="special">}</phrase></programlisting>
          </para>
        </section>
        <section id="documentation.reference.the_sferes2_framework.main_concepts.parameter_handling">
          <title><link linkend="documentation.reference.the_sferes2_framework.main_concepts.parameter_handling">Parameter
          handling</link></title>
          <para>
            The basic parameter format employs static const members in nested structures.
            For instance:
          </para>
          <para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">Param</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">pop</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">size</phrase> <phrase role="special">=</phrase> <phrase role="number">100</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">x</phrase> <phrase role="special">=</phrase> <phrase role="number">0.2f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
<phrase role="special">};</phrase></programlisting>
          </para>
          <para>
            However, c++ does not allow to define static const string or arrays in
            these structures. To solve this problem, sferes2 provides two macros:
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                SFERES_ARRAY(type, name, val1, val2, ...)
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                SFERES_STRING(name, &quot;string&quot;)
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">Param</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">test</phrase>
  <phrase role="special">{</phrase>
    <phrase role="identifier">SFERES_ARRAY</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase><phrase role="special">,</phrase> <phrase role="identifier">my_array</phrase><phrase role="special">,</phrase> <phrase role="number">1.0f</phrase><phrase role="special">,</phrase> <phrase role="number">2.0f</phrase><phrase role="special">,</phrase> <phrase role="number">3.0f</phrase><phrase role="special">);</phrase>
    <phrase role="identifier">SFERES_STRING</phrase><phrase role="special">(</phrase><phrase role="identifier">my_string</phrase><phrase role="special">,</phrase> <phrase role="string">&quot;hello world&quot;</phrase><phrase role="special">);</phrase>
  <phrase role="special">};</phrase>
<phrase role="special">};</phrase></programlisting>
          </para>
          <para>
            These parameters can then be retrieved in the source code in the following
            way:
          </para>
          <para>
<programlisting><phrase role="special">...</phrase>
<phrase role="comment">// size</phrase>
<phrase role="identifier">size_t</phrase> <phrase role="identifier">s</phrase> <phrase role="special">=</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">test</phrase><phrase role="special">::</phrase><phrase role="identifier">my_array_size</phrase><phrase role="special">();</phrase>
<phrase role="comment">// 2nd element</phrase>
<phrase role="keyword">float</phrase> <phrase role="identifier">v</phrase> <phrase role="special">=</phrase> <phrase role="identifier">Param</phrase><phrase role="special">::</phrase><phrase role="identifier">test</phrase><phrase role="special">::</phrase><phrase role="identifier">my_array</phrase><phrase role="special">(</phrase><phrase role="number">2</phrase><phrase role="special">);</phrase>
<phrase role="comment">// string</phrase>
<phrase role="keyword">const</phrase> <phrase role="keyword">char</phrase><phrase role="special">*</phrase> <phrase role="identifier">c</phrase> <phrase role="special">=</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">test</phrase><phrase role="special">::</phrase><phrase role="identifier">my_string</phrase><phrase role="special">();</phrase></programlisting>
          </para>
        </section>
      </section>
      <section id="documentation.reference.the_sferes2_framework.mastering_boost">
        <title><link linkend="documentation.reference.the_sferes2_framework.mastering_boost">Mastering
        boost</link></title>
        <para>
          Sferes2 heavily relies on boost libraries (see <ulink url="http://www.boost.org">http://www.boost.org</ulink>).
          To implement your own algorithms in the sferes2 framework, you should be
          familiar enough with the following libraries:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              boost::shared_ptr: <ulink url="http://www.boost.org/doc/libs/1_40_0/libs/smart_ptr/shared_ptr.htm">http://www.boost.org/doc/libs/1_40_0/libs/smart_ptr/shared_ptr.htm</ulink>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              boost::serialization (useful to define your own genotypes and statistics):
              <ulink url="http://www.boost.org/doc/libs/1_40_0/libs/serialization/doc/index.html">http://www.boost.org/doc/libs/1_40_0/libs/serialization/doc/index.html</ulink>
            </simpara>
          </listitem>
        </itemizedlist>
        <para>
          The following libraries are used in sferes2 but you might never notice
          them:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              BOOST_FOREACH (to simplify loops): <ulink url="http://www.boost.org/doc/libs/1_40_0/doc/html/foreach.html">http://www.boost.org/doc/libs/1_40_0/doc/html/foreach.html</ulink>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              boost::filesystem (to create directories, etc.): <ulink url="http://www.boost.org/doc/libs/1_40_0/libs/filesystem/doc/index.htm">http://www.boost.org/doc/libs/1_40_0/libs/filesystem/doc/index.htm</ulink>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              boost::fusion (list of statistics): <ulink url="http://www.boost.org/doc/libs/1_40_0/libs/fusion/doc/html/index.html">http://www.boost.org/doc/libs/1_40_0/libs/fusion/doc/html/index.html</ulink>
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              boost::mpi (MPI evaluator): <ulink url="http://www.boost.org/doc/libs/1_40_0/doc/html/mpi.html">http://www.boost.org/doc/libs/1_40_0/doc/html/mpi.html</ulink>
            </simpara>
          </listitem>
        </itemizedlist>
      </section>
      <section id="documentation.reference.the_sferes2_framework.uml_diagram">
        <title><link linkend="documentation.reference.the_sferes2_framework.uml_diagram">UML
        Diagram</link></title>
        <para>
          Here is a &quot;conceptual&quot; UML diagram of the sferes2 framework (modules
          are not represented). It's &quot;conceptual&quot; because some abstract
          classes are not implemented (because they are useless from an implementation
          point of view) but should exist in the mind of the user. Moreover, each
          class is parametrized by the Param class (see previous section), which
          is not represented on the diagram.
        </para>
        <para>
          <inlinemediaobject><imageobject><imagedata fileref="../img/sferes.jpg"></imagedata></imageobject>
          <textobject>
            <phrase>sferes</phrase>
          </textobject>
          </inlinemediaobject>
        </para>
      </section>
      <section id="documentation.reference.the_sferes2_framework.overview_of_the_call_graph">
        <title><link linkend="documentation.reference.the_sferes2_framework.overview_of_the_call_graph">Overview
        of the call graph</link></title>
        <para>
          <inlinemediaobject><imageobject><imagedata fileref="../img/call_graph.jpg"></imagedata></imageobject>
          <textobject>
            <phrase>call_graph</phrase>
          </textobject>
          </inlinemediaobject>
        </para>
        <para>
          On this simplified call graph:
        </para>
        <itemizedlist>
          <listitem>
            <simpara>
              ea_t : type of your EA (e.g. ea::Nsga2)
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              eval_t : type of your evaluator (e.g. eval::Parallel)
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              gen_t : type of your phenotype (e.g gen::EvoFloat)
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              modifier_t : type of your modifier (e.g. modif::Dummy)
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              phen_t : type of your phenotype (e.g. phen::Parameters)
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              stat_t : type of your statistics vector (e.g. boost::fusion::vector&lt;stat::BestFit&lt;phen_t&gt;
              &gt; )
            </simpara>
          </listitem>
        </itemizedlist>
        <para>
          Time flows from left to right (i.e. random_pop() is called before epoch()
          and so on). Methods with a double bar are called for each individual or
          each new individual.
        </para>
      </section>
    </section>
    <section id="documentation.reference.main_classes">
      <title><link linkend="documentation.reference.main_classes">Main classes and
      files</link></title>
      <section id="documentation.reference.main_classes.naming_conventions">
        <title><link linkend="documentation.reference.main_classes.naming_conventions">Naming
        conventions</link></title>
        <itemizedlist>
          <listitem>
            <simpara>
              Names representing <emphasis role="bold">classes</emphasis> must be
              in mixed case starting with upper case: MyClass
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">Variable and method names</emphasis> must be
              in lower case, using underscores to separate words: my_variable, my_method()
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              Names of <emphasis role="bold">protected and private members</emphasis>
              must start with an underscore: _my_private_member, _my_private_method()
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">File names</emphasis> must be in lower case,
              using underscores to separate words. A file which contains a class
              MyClass should be put in a file my_class.hpp
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">File structure</emphasis> mirrors namespace structure.
              For instance gen::MyClass is in the file gen/my_class.hpp
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">Named constants</emphasis> (including enumeration
              values) must be all uppercase using underscores to separate words
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">Getters</emphasis> should have the name of the
              attribute. For instance, this-&gt;_objs should be accessed using this-&gt;objs()
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">Setters</emphasis> should start with &quot;set_&quot;
              followed by the name of the attribute. For instance: set_objs(const
              std::vector&lt;float&gt;&amp; ov)
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              The <emphasis role="bold">public section</emphasis> should be the first
              section of a class
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              Type names defined using <emphasis role="bold">typedefs</emphasis>
              should end with _t (e.g. iterator_t)
            </simpara>
          </listitem>
        </itemizedlist>
        <para>
          Full example:
        </para>
        <para>
<programlisting><phrase role="comment">// filename: sferes/fit/my_test.hpp</phrase>
<phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">fit</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">class</phrase> <phrase role="identifier">SFERES_CLASS</phrase><phrase role="special">(</phrase><phrase role="identifier">MyTest</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
    <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
      <phrase role="keyword">typedef</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">f_t</phrase><phrase role="special">;</phrase>
      <phrase role="identifier">MyTest</phrase><phrase role="special">()</phrase> <phrase role="special">{}</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">my_method</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="identifier">_my_impl</phrase><phrase role="special">();</phrase> <phrase role="special">}</phrase>
      <phrase role="keyword">float</phrase> <phrase role="identifier">my_attr</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">_my_attr</phrase><phrase role="special">;}</phrase>
      <phrase role="keyword">float</phrase> <phrase role="identifier">set_my_attr</phrase><phrase role="special">(</phrase><phrase role="keyword">float</phrase> <phrase role="identifier">a</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="identifier">_my_attr</phrase> <phrase role="special">=</phrase> <phrase role="identifier">v</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
    <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
      <phrase role="keyword">float</phrase> <phrase role="identifier">_my_attr</phrase><phrase role="special">;</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">_my_impl</phrase><phrase role="special">()</phrase> <phrase role="special">{}</phrase>
    <phrase role="special">};</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">}</phrase></programlisting>
        </para>
      </section>
      <section id="documentation.reference.main_classes.fitness">
        <title><link linkend="documentation.reference.main_classes.fitness">Fitness</link></title>
        <section id="documentation.reference.main_classes.fitness.fitness">
          <title><link linkend="documentation.reference.main_classes.fitness.fitness">Fitness</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[file:~/svn/sferes2/trunk/sferes/fit/fitness.hpp][sferes/fit/fitness.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis> Fitness is the base
                class of fitness functions in sferes2. It has two main attributes:
                <itemizedlist>
                  <listitem>
                    <simpara>
                      float _value (setter/getter Fitness::value()) -&gt; the value
                      of the fitness for single-objective optimization
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      std::vector&lt;float&gt; _objs (setter/getter Fitness::objs())
                      -&gt; the value of each objective, for multiobjective optimization
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                This class is abstract
              </simpara>
            </listitem>
          </itemizedlist>
        </section>
        <section id="documentation.reference.main_classes.fitness.defining_your_own_fitness">
          <title><link linkend="documentation.reference.main_classes.fitness.defining_your_own_fitness">Defining
          your own fitness</link></title>
          <para>
            In most sferes2 experiments, you will have to design your own fitness.
            A fitness should:
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                be defined using SFERES_FITNESS(MyFitness, sferes::fit::Fitness)
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                define the eval() method, which takes an individual
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                attribute a fitness value in this-&gt;_value (single objective optimization)
                or this-&gt;_objs (multiobjective optimization)
              </simpara>
            </listitem>
          </itemizedlist>
<programlisting><phrase role="identifier">A</phrase> <phrase role="identifier">fitness</phrase> <phrase role="identifier">is</phrase> <phrase role="identifier">a</phrase> <phrase role="string">&quot;normal&quot;</phrase> <phrase role="keyword">class</phrase> <phrase role="keyword">and</phrase> <phrase role="identifier">consequently</phrase> <phrase role="identifier">you</phrase> <phrase role="identifier">can</phrase>
 <phrase role="identifier">add</phrase> <phrase role="identifier">other</phrase> <phrase role="identifier">methods</phrase> <phrase role="keyword">or</phrase> <phrase role="identifier">attributes</phrase> <phrase role="identifier">to</phrase> <phrase role="identifier">suit</phrase> <phrase role="identifier">your</phrase> <phrase role="identifier">needs</phrase><phrase role="special">.</phrase>
</programlisting>
          <para>
            Example:
<programlisting><phrase role="comment">// single objective fitess</phrase>
<phrase role="identifier">SFERES_FITNESS</phrase><phrase role="special">(</phrase><phrase role="identifier">FitnessSingle</phrase><phrase role="special">,</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">fitness</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="comment">// (optional) constructor</phrase>
  <phrase role="identifier">FitnessSingle</phrase><phrase role="special">()</phrase>
    <phrase role="special">{</phrase>
      <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_value</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="number">1</phrase><phrase role="special">;</phrase>
    <phrase role="special">}</phrase>
  <phrase role="comment">// evaluation</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="identifier">Indiv</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">indiv</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_value</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="number">42</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">};</phrase>

<phrase role="comment">// two-objective fitness</phrase>
<phrase role="identifier">SFERES_FITNESS</phrase><phrase role="special">(</phrase><phrase role="identifier">FitnessMulti</phrase><phrase role="special">,</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">fitness</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="comment">// constructor</phrase>
  <phrase role="identifier">FitnessMulti</phrase><phrase role="special">()</phrase>
    <phrase role="special">{</phrase>
      <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">.</phrase><phrase role="identifier">resize</phrase><phrase role="special">(</phrase><phrase role="number">2</phrase><phrase role="special">);</phrase>
    <phrase role="special">}</phrase>
  <phrase role="comment">// evaluation</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="identifier">Indiv</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">indiv</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">[</phrase><phrase role="number">0</phrase><phrase role="special">]</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="number">42</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_objs</phrase><phrase role="special">[</phrase><phrase role="number">1</phrase><phrase role="special">]</phrase> <phrase role="special">=</phrase> <phrase role="number">42</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">};</phrase>
</programlisting>
          </para>
        </section>
        <section id="documentation.reference.main_classes.fitness.view_mode">
          <title><link linkend="documentation.reference.main_classes.fitness.view_mode">View
          mode</link></title>
          <para>
            When loading a result file, it is often useful to slightly change the
            fitness function, for instance to display/log data about the behavior
            of the individual. This can be easily done in sferes2 using the boolean
            Fitness::mode() than can takes two values:
          </para>
<programlisting><phrase role="special">*</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">mode</phrase><phrase role="special">::</phrase><phrase role="identifier">view</phrase> <phrase role="identifier">when</phrase> <phrase role="identifier">you</phrase> <phrase role="identifier">are</phrase> <phrase role="identifier">viewing</phrase> <phrase role="identifier">an</phrase> <phrase role="identifier">individual</phrase> <phrase role="identifier">via</phrase> <phrase role="special">--</phrase><phrase role="identifier">load</phrase>
<phrase role="special">*</phrase> <phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">mode</phrase><phrase role="special">::</phrase><phrase role="identifier">eval</phrase> <phrase role="identifier">when</phrase> <phrase role="identifier">you</phrase> <phrase role="identifier">are</phrase> <phrase role="identifier">evaluting</phrase> <phrase role="identifier">individuals</phrase> <phrase role="special">(</phrase><phrase role="identifier">during</phrase> <phrase role="identifier">the</phrase>
  <phrase role="identifier">evolutionary</phrase> <phrase role="identifier">process</phrase><phrase role="special">)</phrase>
</programlisting>
          <para>
            Example:
          </para>
          <para>
<programlisting><phrase role="comment">// single objective fitess</phrase>
<phrase role="identifier">SFERES_FITNESS</phrase><phrase role="special">(</phrase><phrase role="identifier">FitnessSingle</phrase><phrase role="special">,</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">fitness</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="comment">// evaluation</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase>
    <phrase role="keyword">void</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="identifier">Indiv</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">indiv</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">mode</phrase><phrase role="special">()</phrase> <phrase role="special">==</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">fit</phrase><phrase role="special">::</phrase><phrase role="identifier">mode</phrase><phrase role="special">::</phrase><phrase role="identifier">view</phrase><phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
      <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ofstream</phrase> <phrase role="identifier">ofs</phrase><phrase role="special">(</phrase><phrase role="string">&quot;fit.dat&quot;</phrase><phrase role="special">);</phrase>
      <phrase role="identifier">ofs</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="string">&quot;this is a log file !&quot;</phrase><phrase role="special">&lt;&lt;</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">endl</phrase><phrase role="special">;</phrase>
      <phrase role="special">}</phrase>
    <phrase role="keyword">this</phrase><phrase role="special">-&gt;</phrase><phrase role="identifier">_value</phrase> <phrase role="special">=</phrase> <phrase role="special">-</phrase><phrase role="number">42</phrase><phrase role="special">;</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">};</phrase></programlisting>
          </para>
        </section>
      </section>
      <section id="documentation.reference.main_classes.evolutionary_algorithms">
        <title><link linkend="documentation.reference.main_classes.evolutionary_algorithms">Evolutionary
        algorithms</link></title>
        <itemizedlist>
          <listitem>
            <simpara>
              Warning* Evolutionary algorithms <emphasis>maximize</emphasis> the
              fitness (whereas most optimization algorithms minimize the cost function).
            </simpara>
          </listitem>
        </itemizedlist>
        <section id="documentation.reference.main_classes.evolutionary_algorithms.shared_parameters">
          <title><link linkend="documentation.reference.main_classes.evolutionary_algorithms.shared_parameters">Shared
          parameters</link></title>
          <para>
            All evolutionary algorithms (EA) use the following parameters:
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                static const size_t Params::pop::size = population size
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                static const float Params::pop::initial_aleat = during the random
                generation, Params::pop::initial_aleat \times Params::pop::size individuals
                are generated and only the Params::pop::size best ones are kept
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                static const int Params::pop::dump_period: the period between each
                write of results, examples: - 1: statistics are written at each generation
                (gen_0, gen_1, gen_2, ...) - -1: statistics are never written (useful
                for unit tests) - 10: statistics are written each 10 generations
                (gen_0, gen_10, ...)
              </simpara>
            </listitem>
          </itemizedlist>
        </section>
        <section id="documentation.reference.main_classes.evolutionary_algorithms.ranksimple">
          <title><link linkend="documentation.reference.main_classes.evolutionary_algorithms.ranksimple">RankSimple</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[file:~/svn/sferes2/trunk/sferes/ea/rank_simple.hpp][sferes/ea/rank_simple.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Unit test:</emphasis> [[file:~/svn/sferes2/trunk/tests/ea/rank_simple.cpp][tests/ea/rank_simple.cpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical typename:</emphasis>:
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">ea</phrase><phrase role="special">::</phrase><phrase role="identifier">RankSimple</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">stat_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">modifier_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">ea_t</phrase><phrase role="special">;</phrase></programlisting>
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis> A rank-based single-objective
                evolutionary algorithm. Individuals are selected using the following
                formula:
                <itemizedlist>
                  <listitem>
                    <simpara>
                      n = k_r \times p
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      \kappa = c^{n + 1} - 1
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      f = n / (\kappa + 1)
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      i = p - f \times log(r \times \kappa + 1)
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      where - c = Params::pop::coeff - k_r = Params::pop::keep_rate
                      - p = Params::pop::size - r = a random number in [0,1[ - i
                      = index of the selected individual
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                parameters:
                <itemizedlist>
                  <listitem>
                    <simpara>
                      static const float Params::pop::coeff = a internal parameter
                      (see the previous formula) ; typical value : 1.1
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      static const float Params::pop::keep_rate = proportion of individuals
                      kept from a generation to the next one ; typical value : 0.2
                      to 0.6
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
          </itemizedlist>
        </section>
        <section id="documentation.reference.main_classes.evolutionary_algorithms.nsga2">
          <title><link linkend="documentation.reference.main_classes.evolutionary_algorithms.nsga2">Nsga2</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[../../sferes/ea/nsga2.hpp][sferes/ea/nsga2.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Unit test:</emphasis> [[file:~/svn/sferes2/trunk/tests/ea/nsga2.cpp][tests/ea/nsga2.cpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                Example: [[file:~/svn/sferes2/trunk/examples/ex_nsga2.cpp][examples/ex_nsga2.cpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical typename:</emphasis>:
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">ea</phrase><phrase role="special">::</phrase><phrase role="identifier">Nsga2</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">stat_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">modifier_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">ea_t</phrase><phrase role="special">;</phrase></programlisting>
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis> Implementation of the
                NSGA-II multiobjective evolutionary algorithm. See:
                <itemizedlist>
                  <listitem>
                    <simpara>
                      Deb, K. (2001). Multi-Objective Optimization Using Evolutionary
                      Algorithms. <emphasis>Wiley</emphasis>.
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      Deb, K., Pratap, A., Agarwal, S. and Meyarivan, T. (2002).
                      A fast and elitist multiobjective genetic algorithm: NSGA-II.
                      In <emphasis>IEEE transactions on evolutionary computation</emphasis>,
                      6:2:182-197
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Parameters:</emphasis> pop_size must be divisible
                by 4
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Note:</emphasis> NSGA-II can be efficient for
                single-objective optimization as it corresponds to a classic tournament-based
                evolutionary algorithm. In sferes2, a 1-sized _objs vector in the
                fitness can be employed (don't use _value).
              </simpara>
            </listitem>
          </itemizedlist>
        </section>
        <section id="documentation.reference.main_classes.evolutionary_algorithms.epsmoea">
          <title><link linkend="documentation.reference.main_classes.evolutionary_algorithms.epsmoea">EpsMOEA</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[../../sferes/ea/eps_moea.hpp][sferes/ea/eps_moea.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Unit test:</emphasis> [[file:~/svn/sferes2/trunk/tests/ea/eps_moea.cpp][tests/ea/eps_moea.cpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical typename:</emphasis>:
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">ea</phrase><phrase role="special">::</phrase><phrase role="identifier">EpsMOEA</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">stat_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">modifier_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">ea_t</phrase></programlisting>
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis> Implementation of the
                \varepsilon-MOEA multiobjective evolutionary algorithm. See:
                <itemizedlist>
                  <listitem>
                    <simpara>
                      Deb, K., Mohan, M. and Mishra, S. (2005). Evaluating the \varepsilon-domination
                      based multi-objective evolutionary algorithm for a quick computation
                      of pareto-optimal solutions. In <emphasis>Evolutionary Computation</emphasis>,
                      13:4:501-525.
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Parameters:</emphasis>
                <itemizedlist>
                  <listitem>
                    <simpara>
                      SFERES_ARRAY(float, eps, 0.0075f, 0.0075f) = values of \varepsilon
                      for each objective. There should be as many values as objectives.
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      SFERES_ARRAY(float, min_fit, 0.0f, 0.0f) = minimum value of
                      fitness for each objective.There should as many values as objectives
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      static const size_t grain = \varepsilon-MOEA is a steady*state
                      algorithm which adds individuals one by one. A basic implementation
                      would prevent the parallelization of individuals' evaluation.
                      The parameter grain allows to generate and evaluate <emphasis>grain</emphasis>
                      indidividuals in paralell at each generation. Typical value
                      is size / 4.
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Notes:</emphasis>
                <itemizedlist>
                  <listitem>
                    <simpara>
                      \varepsilon-MOEA employs \varepsilon-dominance to sort individuals.
                      This allows users to tune the precision of the pareto front
                      for each objective and often results in better performance
                      than NSGA-II.
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      EpsMOEA should not be used with a modifier (because it uses
                      an archive). You should always use fit::ModifierDummy
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
          </itemizedlist>
        </section>
        <section id="documentation.reference.main_classes.evolutionary_algorithms.defining_your_own_ea">
          <title><link linkend="documentation.reference.main_classes.evolutionary_algorithms.defining_your_own_ea">Defining
          your own EA</link></title>
          <para>
            To define your own EA, you should use the macro SFERES_EA(Class, Parent).
            Mandatory methods:
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                random_pop(): fill this-&gt;_pop with random individuals
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                epoch(): main loop of the algorithm
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
            Defined types (these types will be available in your class):
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                Phen: phenotype
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                Eval: evaluator
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                Stat: statistics vector
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                FitModifier: modifier
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                Params: parameters
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="identifier">SFERES_EA</phrase><phrase role="special">(</phrase><phrase role="identifier">Test</phrase><phrase role="special">,</phrase> <phrase role="identifier">Ea</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
 <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
 <phrase role="identifier">Test</phrase><phrase role="special">()</phrase> <phrase role="special">{}</phrase>
 <phrase role="keyword">void</phrase> <phrase role="identifier">random_pop</phrase><phrase role="special">()</phrase>
 <phrase role="special">{</phrase> <phrase role="comment">/* your code */</phrase> <phrase role="special">}</phrase>
 <phrase role="keyword">void</phrase> <phrase role="identifier">epoch</phrase><phrase role="special">()</phrase>
 <phrase role="special">{</phrase> <phrase role="comment">/* your code */</phrase> <phrase role="special">}</phrase>
<phrase role="special">};</phrase></programlisting>
          </para>
          <para>
            Multiobjective EA must also define a pareto_front() method, see [<emphasis
            role="bold">ParetoFront</emphasis>[ParetoFront]].
          </para>
        </section>
      </section>
      <section id="documentation.reference.main_classes.statistics">
        <title><link linkend="documentation.reference.main_classes.statistics">Statistics</link></title>
        <para>
          Statistics should be combined in a boost::fusion::vector (see: <ulink url="http://www.boost.org/doc/libs/1_40_0/libs/fusion/doc/html/fusion/container/vector.html">boost
          fusion</ulink>) before being passed to a EA. For instance:
        </para>
        <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">fusion</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">stat</phrase><phrase role="special">::</phrase><phrase role="identifier">BestFit</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;,</phrase> <phrase role="identifier">stat</phrase><phrase role="special">::</phrase><phrase role="identifier">MeanFit</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase>  <phrase role="identifier">stat_t</phrase><phrase role="special">;</phrase></programlisting>
        </para>
        <para>
          (yes, it is a vector of <emphasis>typenames</emphasis>). You can put in
          the vector as many statistics types as you desire.
        </para>
        <section id="documentation.reference.main_classes.statistics.bestfit">
          <title><link linkend="documentation.reference.main_classes.statistics.bestfit">BestFit</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[file:~/svn/sferes2/trunk/sferes/stat/best_fit.hpp][sferes/stat/best_fit.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical typename:</emphasis>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">fusion</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">ea</phrase><phrase role="special">::</phrase><phrase role="identifier">BestFit</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">stat_t</phrase><phrase role="special">;</phrase></programlisting>
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis>
                <itemizedlist>
                  <listitem>
                    <simpara>
                      stores the individual with the highest fitness in _best (getter:
                      BestFit::best() ). <emphasis>This assumes that the population
                      is sorted</emphasis> and consequently this statistics stores
                      the first individual of the population.
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      This class is designed for single objective optimization and
                      consequently works using Fitness::_value (and not Fitness::_objs)
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      writes the value of the best fitness in the file &lt;result_directory&gt;/bestfit.dat
                      ; this file should be easily plotted with gnuplot or R.
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
          </itemizedlist>
        </section>
        <section id="documentation.reference.main_classes.statistics.meanfit">
          <title><link linkend="documentation.reference.main_classes.statistics.meanfit">MeanFit</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[file:~/svn/sferes2/trunk/sferes/stat/mean_fit.hpp][sferes/stat/mean_fit.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical typename:</emphasis>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">fusion</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">ea</phrase><phrase role="special">::</phrase><phrase role="identifier">MeanFit</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">stat_t</phrase><phrase role="special">;</phrase></programlisting>
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis> computes the mean fitness
                (single objective, based on Fitness::_value). This class is mainly
                aimed at providing a simple example of statistics.
              </simpara>
            </listitem>
          </itemizedlist>
        </section>
        <section id="documentation.reference.main_classes.statistics.paretofront">
          <title><link linkend="documentation.reference.main_classes.statistics.paretofront">ParetoFront</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[file:~/svn/sferes2/trunk/sferes/stat/pareto_front.hpp][sferes/stat/pareto_front.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical typename:</emphasis>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">fusion</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">ea</phrase><phrase role="special">::</phrase><phrase role="identifier">ParetoFront</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">phen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;</phrase> <phrase role="identifier">stat_t</phrase><phrase role="special">;</phrase></programlisting>
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis> stores the set of non-dominated
                individuals by copying the list returned by ea_t::pareto_front().
                ParetoFront does not compute the pareto front; this class assumes
                that the EA computed it. This implies that multiobjective EA classes
                should define the following method:
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="identifier">SFERES_EA</phrase><phrase role="special">(</phrase><phrase role="identifier">MyEA</phrase><phrase role="special">,</phrase> <phrase role="identifier">Ea</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
 <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
  <phrase role="identifier">std</phrase><phrase role="special">:</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Indiv</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&amp;</phrase><phrase role="identifier">pareto_front</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="special">{</phrase> <phrase role="comment">/* your code */</phrase> <phrase role="special">}</phrase>
<phrase role="special">};</phrase></programlisting>
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">Note:</emphasis> since this statistic can store
                many individuals, to load a result file you must give the identifier
                (the rank in the Pareto front) to your executable. For instance,
                assuming that ParetoFront in the first (0th) statistics in the stat
                vector, loading the 10th individual should look like:
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting>./my_exp --load gen_100 -s 0 -n 10 -o output</programlisting>
          </para>
        </section>
        <section id="documentation.reference.main_classes.statistics.defining_your_own_statistics">
          <title><link linkend="documentation.reference.main_classes.statistics.defining_your_own_statistics">Defining
          your own statistics</link></title>
          <para>
<programlisting><phrase role="identifier">SFERES_STAT</phrase><phrase role="special">(</phrase><phrase role="identifier">MyStat</phrase><phrase role="special">,</phrase> <phrase role="identifier">Stat</phrase><phrase role="special">)</phrase>
<phrase role="special">{</phrase>
  <phrase role="comment">// examines the population (via the EA) to update the statistics</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">E</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">void</phrase> <phrase role="identifier">refresh</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">E</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">ea</phrase><phrase role="special">)</phrase> <phrase role="special">{</phrase> <phrase role="comment">/* your code */</phrase> <phrase role="special">}</phrase>
  <phrase role="comment">// writes the content of the statistics in the stream; k is the number</phrase>
  <phrase role="comment">// of the individual in the statistics (e.g. in a Pareto front, the</phrase>
  <phrase role="comment">// statistics contains many individuals)</phrase>
  <phrase role="keyword">void</phrase> <phrase role="identifier">show</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">k</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase> <phrase role="special">{</phrase> <phrase role="comment">/* your code */</phrase> <phrase role="special">}</phrase>
  <phrase role="comment">// serializes the statistics using boost::serialization</phrase>
  <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">class</phrase> <phrase role="identifier">Archive</phrase><phrase role="special">&gt;</phrase> <phrase role="keyword">void</phrase> <phrase role="identifier">serialize</phrase><phrase role="special">(</phrase><phrase role="identifier">Archive</phrase> <phrase role="special">&amp;</phrase> <phrase role="identifier">ar</phrase><phrase role="special">,</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">unsigned</phrase> <phrase role="keyword">int</phrase> <phrase role="identifier">version</phrase><phrase role="special">)</phrase>
  <phrase role="special">{</phrase> <phrase role="comment">/* your code */</phrase> <phrase role="special">}</phrase>
<phrase role="special">}</phrase></programlisting>
          </para>
        </section>
      </section>
      <section id="documentation.reference.main_classes.genotypes">
        <title><link linkend="documentation.reference.main_classes.genotypes">Genotypes</link></title>
        <section id="documentation.reference.main_classes.genotypes.bitstring">
          <title><link linkend="documentation.reference.main_classes.genotypes.bitstring">BitString</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[file:~/svn/sferes2/trunk/sferes/gen/bit_string.hpp][sferes/gen/bit_string.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Unit test:</emphasis> [[../../tests/gen/bit_string.hpp][sferes/gen/bit_string.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis> vector of bitstrings
                which can be used to represent a vector of integer parameters or
                a vector of discrete parameters. Cross-over is a simple one point
                cross-over (it always happens). The data can be easily converted
                to int (in the range 0..2^b, where b is the number of bits for each
                bitstring) via BitString&lt;&gt;::int_data(i) or to float (in the
                range 0..1) via BitString&lt;&gt;::data(i)
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Template parameter:</emphasis> the number of
                bitstrings
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Parameters (struct bit\_string):</emphasis>
                <itemizedlist>
                  <listitem>
                    <simpara>
                      static const size_t nb_bits -&gt; number of bits for each bitstring
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      static const float mutation_rate -&gt; the mutation rate for
                      a bitstring (the bitstring i is mutated if a random real is
                      belows mutation_rate)
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      static const float mutation_rate_bit -&gt; the mutation rate
                      <emphasis>for each bit</emphasis>. In pseudo-code, here is
                      the mutation procedure:
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="identifier">foreach</phrase><phrase role="special">(</phrase><phrase role="identifier">bitstring</phrase> <phrase role="identifier">b</phrase> <phrase role="identifier">in</phrase> <phrase role="identifier">genotype</phrase><phrase role="special">)</phrase>
  <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">rand</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">,</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">bit_string</phrase><phrase role="special">::</phrase><phrase role="identifier">mutation_rate</phrase><phrase role="special">)</phrase>
    <phrase role="identifier">foreach</phrase><phrase role="special">(</phrase><phrase role="identifier">bit</phrase> <phrase role="identifier">i</phrase> <phrase role="identifier">in</phrase> <phrase role="identifier">b</phrase><phrase role="special">)</phrase>
      <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">rand</phrase><phrase role="special">(</phrase><phrase role="number">0</phrase><phrase role="special">,</phrase> <phrase role="number">1</phrase><phrase role="special">)</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">Params</phrase><phrase role="special">::</phrase><phrase role="identifier">bit_string</phrase><phrase role="special">::</phrase><phrase role="identifier">mutation_bit</phrase><phrase role="special">)</phrase>
        <phrase role="identifier">flip</phrase><phrase role="special">(</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>   </programlisting>
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical parameters:</emphasis>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">struct</phrase> <phrase role="identifier">Params</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">bit_string</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">nb_bits</phrase> <phrase role="special">=</phrase> <phrase role="number">8</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">mutate_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">mutate_rate_bit</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
<phrase role="special">};</phrase></programlisting>
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical typename:</emphasis>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">BitString</phrase><phrase role="special">&lt;</phrase><phrase role="number">10</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">gen_t</phrase><phrase role="special">;</phrase></programlisting>
          </para>
        </section>
        <section id="documentation.reference.main_classes.genotypes.evofloat">
          <title><link linkend="documentation.reference.main_classes.genotypes.evofloat">EvoFloat</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[file:~/svn/sferes2/trunk/sferes/gen/evo_float.hpp][sferes/gen/evo_float.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Unit test:</emphasis> [[file:~/svn/sferes2/trunk/tests/gen/evo_float.cpp][sferes/tests/gen/evo_float.cpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis> This genotype is a
                n-sized vector of real (float) numbers. It is designed for real optimization.
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                Three mutation types are available:
                <itemizedlist>
                  <listitem>
                    <simpara>
                      polynomial: polynomial mutation, as defined in Deb(200)1, p
                      124
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      gaussian: adds a gaussian noise to the current value; the variance
                      is a user-specified parameter
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      uniform: adds a uniform noise to the current value; the range
                      is a user-specified parameter
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                Two cross-over types are available (you can disable cross-over by
                using a cross_rate equals to 0)
                <itemizedlist>
                  <listitem>
                    <simpara>
                      recombination:
                      <itemizedlist>
                        <listitem>
                          <simpara>
                            a number k is randomly chosen
                          </simpara>
                        </listitem>
                        <listitem>
                          <simpara>
                            the first child is made of the [0, k[ values of the first
                            parent and of the [k, n-1[ values of the second parent
                          </simpara>
                        </listitem>
                        <listitem>
                          <simpara>
                            the second child is made of the [0, k[ values of the
                            second parent and of the [k, n-1] values of the first
                            parent
                          </simpara>
                        </listitem>
                      </itemizedlist>
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      SBX (simulated binary cross-over, cf Deb (2001), p 113). Warning:
                      the current implementation is copied from Deb's code and is
                      slightly different from the original paper.
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Parameters:</emphasis>
                <itemizedlist>
                  <listitem>
                    <simpara>
                      Any variant:
                      <itemizedlist>
                        <listitem>
                          <simpara>
                            (mutation_t and cross_over_t are defined in the namespace
                            sferes::gen::evo_float)
                          </simpara>
                        </listitem>
                        <listitem>
                          <simpara>
                            static const mutation_t mutation_type: polynomial, gaussian
                            or uniform;
                          </simpara>
                        </listitem>
                        <listitem>
                          <simpara>
                            static const cross_over_t cross_over_type -&gt; sbx or
                            recombination;
                          </simpara>
                        </listitem>
                        <listitem>
                          <simpara>
                            static const float mutation_rate -&gt; the rate of mutation
                            of one member of the vector
                          </simpara>
                        </listitem>
                        <listitem>
                          <simpara>
                            static const float cross_rate -&gt; the rate of cross-over
                            (if no cross-over is applied, parents are copied to children)
                          </simpara>
                        </listitem>
                      </itemizedlist>
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      polynomial mutation:
                      <itemizedlist>
                        <listitem>
                          <simpara>
                            static const float eta_m -&gt; \eta_m is a parameter
                            which controls the polynomial distribution. See Deb's
                            paper or book.
                          </simpara>
                        </listitem>
                      </itemizedlist>
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      gaussian mutation:
                      <itemizedlist>
                        <listitem>
                          <simpara>
                            static const float sigma -&gt; the standard deviation
                            of the gaussian
                          </simpara>
                        </listitem>
                      </itemizedlist>
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      uniform mutation:
                      <itemizedlist>
                        <listitem>
                          <simpara>
                            static const float max -&gt; maximum change of the current
                            value
                          </simpara>
                        </listitem>
                      </itemizedlist>
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      sbx:
                      <itemizedlist>
                        <listitem>
                          <simpara>
                            static const float eta_c -&gt; see Deb's paper or book.
                          </simpara>
                        </listitem>
                      </itemizedlist>
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical typename:</emphasis>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">EvoFloat</phrase><phrase role="special">&lt;</phrase><phrase role="number">10</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params1</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">gen_t</phrase><phrase role="special">;</phrase></programlisting>
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical parameters:</emphasis>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">using</phrase> <phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase><phrase role="special">::</phrase><phrase role="identifier">gen</phrase><phrase role="special">::</phrase><phrase role="identifier">evo_float</phrase><phrase role="special">;</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">Params1</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">evo_float</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">mutation_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">cross_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">mutation_t</phrase> <phrase role="identifier">mutation_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">polynomial</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">cross_over_t</phrase> <phrase role="identifier">cross_over_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">sbx</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_m</phrase> <phrase role="special">=</phrase> <phrase role="number">15.0f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_c</phrase> <phrase role="special">=</phrase> <phrase role="number">15.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">Params2</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">evo_float</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">mutation_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">cross_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">mutation_t</phrase> <phrase role="identifier">mutation_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">gaussian</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">cross_over_t</phrase> <phrase role="identifier">cross_over_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">recombination</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">sigma</phrase> <phrase role="special">=</phrase> <phrase role="number">0.3f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
<phrase role="special">};</phrase>

<phrase role="keyword">struct</phrase> <phrase role="identifier">Params3</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">struct</phrase> <phrase role="identifier">evo_float</phrase>
  <phrase role="special">{</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">mutation_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">cross_rate</phrase> <phrase role="special">=</phrase> <phrase role="number">0.1f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">mutation_t</phrase> <phrase role="identifier">mutation_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">uniform</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="identifier">cross_over_t</phrase> <phrase role="identifier">cross_over_type</phrase> <phrase role="special">=</phrase> <phrase role="identifier">sbx</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">max</phrase> <phrase role="special">=</phrase> <phrase role="number">0.3f</phrase><phrase role="special">;</phrase>
    <phrase role="keyword">static</phrase> <phrase role="keyword">const</phrase> <phrase role="keyword">float</phrase> <phrase role="identifier">eta_c</phrase> <phrase role="special">=</phrase> <phrase role="number">15.0f</phrase><phrase role="special">;</phrase>
  <phrase role="special">};</phrase>
<phrase role="special">};</phrase></programlisting>
          </para>
        </section>
        <section id="documentation.reference.main_classes.genotypes.defining_your_own_genotype">
          <title><link linkend="documentation.reference.main_classes.genotypes.defining_your_own_genotype">Defining
          your own genotype</link></title>
          <para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">stc</phrase><phrase role="special">/</phrase><phrase role="identifier">stc</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">gen</phrase>
  <phrase role="special">{</phrase>
    <phrase role="identifier">SFERES_CLASS</phrase><phrase role="special">(</phrase><phrase role="identifier">MyGenotype</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
    <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
      <phrase role="comment">// generates a random genotype</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">random</phrase><phrase role="special">()</phrase>
      <phrase role="special">{</phrase>
      <phrase role="comment">// your code</phrase>
      <phrase role="special">}</phrase>
      <phrase role="comment">// mutates an individual</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">mutate</phrase><phrase role="special">()</phrase>
      <phrase role="special">{</phrase>
      <phrase role="comment">// your code to mutate (you have to handle your own mutation_rate)</phrase>
      <phrase role="special">}</phrase>
      <phrase role="comment">// WARNING: the arguments of this method are of the same type</phrase>
      <phrase role="comment">// than your genotype</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">cross</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">MyGenotype</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">o</phrase><phrase role="special">,</phrase> <phrase role="identifier">MyGenotype</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">c1</phrase><phrase role="special">,</phrase> <phrase role="identifier">MyGenotype</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">c2</phrase><phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
      <phrase role="comment">// if you don't know what to do, simply use:</phrase>
      <phrase role="keyword">if</phrase> <phrase role="special">(</phrase><phrase role="identifier">misc</phrase><phrase role="special">::</phrase><phrase role="identifier">flip_coin</phrase><phrase role="special">())</phrase>
        <phrase role="special">{</phrase>
          <phrase role="identifier">c1</phrase> <phrase role="special">=</phrase> <phrase role="special">*</phrase><phrase role="keyword">this</phrase><phrase role="special">;</phrase>
          <phrase role="identifier">c2</phrase> <phrase role="special">=</phrase> <phrase role="identifier">o</phrase><phrase role="special">;</phrase>
          <phrase role="special">}</phrase>
        <phrase role="keyword">else</phrase>
          <phrase role="special">{</phrase>
            <phrase role="identifier">c2</phrase> <phrase role="special">=</phrase> <phrase role="special">*</phrase><phrase role="keyword">this</phrase><phrase role="special">;</phrase>
            <phrase role="identifier">c1</phrase> <phrase role="special">=</phrase> <phrase role="identifier">o</phrase><phrase role="special">;</phrase>
          <phrase role="special">}</phrase>
      <phrase role="special">}</phrase>
    <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
      <phrase role="comment">// your data here (your genotype)</phrase>
    <phrase role="special">};</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">}</phrase></programlisting>
          </para>
        </section>
      </section>
      <section id="documentation.reference.main_classes.phenotypes__individuals_">
        <title><link linkend="documentation.reference.main_classes.phenotypes__individuals_">Phenotypes
        (Individuals)</link></title>
        <para>
          Phenotypes are the expression of the genotypes: it is often useful to develop
          a genotype into a structure which is easier to evaluate. For instance,
          a neural network can be encoded with a compact encoding (genotype, e.g.
          a modular encoding which can repeat the same module several times), then
          developped into a standard neural network (phenotype).
        </para>
        <para>
          Phenotypes are also the bridge between the fitness function and the genotype.
          In sferes2, a phenotype is the composition of a fit_t and a gen_t.
        </para>
        <section id="documentation.reference.main_classes.phenotypes__individuals_.indiv">
          <title><link linkend="documentation.reference.main_classes.phenotypes__individuals_.indiv">Indiv</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[file:~/svn/sferes2/trunk/sferes/indiv.hpp][sferes/phen/indiv.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis> The abstract base class
                for phenotypes.
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Main public methods:</emphasis>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="comment">// returns the fitness</phrase>
<phrase role="identifier">Fit</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">fit</phrase><phrase role="special">();</phrase>
<phrase role="keyword">const</phrase> <phrase role="identifier">Fit</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">fit</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase><phrase role="special">;</phrase>
<phrase role="comment">// returns the genotype</phrase>
<phrase role="identifier">Gen</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">gen</phrase><phrase role="special">()</phrase>  <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">_gen</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
<phrase role="keyword">const</phrase> <phrase role="identifier">Gen</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">gen</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="special">{</phrase> <phrase role="keyword">return</phrase> <phrase role="identifier">_gen</phrase><phrase role="special">;</phrase> <phrase role="special">}</phrase>
<phrase role="comment">// develops the genotype, called by the evalutar before evaluating</phrase>
<phrase role="comment">// the individual</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">develop</phrase><phrase role="special">();</phrase>
<phrase role="comment">// you can also override the following methods (although in most</phrase>
<phrase role="comment">// cases, you should override their equivalent in the genotype)</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">mutate</phrase><phrase role="special">();</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">random</phrase><phrase role="special">();</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">cross</phrase><phrase role="special">(</phrase><phrase role="keyword">const</phrase> <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">shared_ptr</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Exact</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">i2</phrase><phrase role="special">,</phrase>
         <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">shared_ptr</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Exact</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">o1</phrase><phrase role="special">,</phrase>
         <phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">shared_ptr</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Exact</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">o2</phrase><phrase role="special">);</phrase>
<phrase role="comment">// this method is not implemented in Indiv but it must be in all the</phrase>
<phrase role="comment">// concrete genotypes. It should describe this particular individual</phrase>
<phrase role="comment">// in the stream os (see the Parameter source code for an example)</phrase>
<phrase role="keyword">void</phrase> <phrase role="identifier">show</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase></programlisting>
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">Defined types:</emphasis>
                <itemizedlist>
                  <listitem>
                    <simpara>
                      Fit -&gt; the fitness functor
                    </simpara>
                  </listitem>
                  <listitem>
                    <simpara>
                      Gen -&gt; genotype
                    </simpara>
                  </listitem>
                </itemizedlist>
              </simpara>
            </listitem>
          </itemizedlist>
        </section>
        <section id="documentation.reference.main_classes.phenotypes__individuals_.parameters">
          <title><link linkend="documentation.reference.main_classes.phenotypes__individuals_.parameters">Parameters</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[file:~/svn/sferes2/trunk/sferes/phen/parameters.hpp][sferes/gen/parameters.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Unit test:</emphasis> [[file:~/svn/sferes2/trunk/tests/phen/parameters.cpp][sferes/tests/phen/parameters.cpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis> This phenotype transforms
                a list of parameters in [0, 1[ (typically a gen::Bitstring or a gen::EvoFloat)
                to a list of parameter in [min, max[. The genotype class must define
                a method:
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="identifier">cont</phrase> <phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">float</phrase><phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">data</phrase><phrase role="special">()</phrase> <phrase role="keyword">const</phrase> <phrase role="special">();</phrase></programlisting>
          </para>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical typename:</emphasis>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">eval</phrase><phrase role="special">::</phrase><phrase role="identifier">Parameters</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">gen_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">fit_t</phrase><phrase role="special">,</phrase> <phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">phen_t</phrase><phrase role="special">;</phrase></programlisting>
          </para>
        </section>
        <section id="documentation.reference.main_classes.phenotypes__individuals_.defining_your_own_phenotype">
          <title><link linkend="documentation.reference.main_classes.phenotypes__individuals_.defining_your_own_phenotype">Defining
          your own phenotype</link></title>
          <para>
<programlisting><phrase role="preprocessor">#include</phrase> <phrase role="special">&lt;</phrase><phrase role="identifier">sferes</phrase><phrase role="special">/</phrase><phrase role="identifier">phen</phrase><phrase role="special">/</phrase><phrase role="identifier">indiv</phrase><phrase role="special">.</phrase><phrase role="identifier">hpp</phrase><phrase role="special">&gt;</phrase>
<phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">phen</phrase>
  <phrase role="special">{</phrase>
    <phrase role="identifier">SFERES_INDIV</phrase><phrase role="special">(</phrase><phrase role="identifier">MyPhenotype</phrase><phrase role="special">,</phrase> <phrase role="identifier">Indiv</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
    <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
      <phrase role="comment">// constructor</phrase>
      <phrase role="identifier">MyPhenotype</phrase><phrase role="special">()</phrase> <phrase role="special">{</phrase> <phrase role="comment">/* your code */</phrase> <phrase role="special">}</phrase>
      <phrase role="comment">// develop the genotype to whatever you want</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">develop</phrase><phrase role="special">(){</phrase> <phrase role="comment">/* your code */</phrase> <phrase role="special">}</phrase>
      <phrase role="comment">// describe this individual</phrase>
      <phrase role="keyword">void</phrase> <phrase role="identifier">show</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">ostream</phrase><phrase role="special">&amp;</phrase> <phrase role="identifier">os</phrase><phrase role="special">)</phrase> <phrase role="keyword">const</phrase> <phrase role="special">{</phrase> <phrase role="comment">/* your code */</phrase> <phrase role="special">}</phrase>
    <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
      <phrase role="comment">// your data</phrase>
    <phrase role="special">};</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">}</phrase></programlisting>
          </para>
        </section>
      </section>
      <section id="documentation.reference.main_classes.evaluators">
        <title><link linkend="documentation.reference.main_classes.evaluators">Evaluators</link></title>
        <para>
          Evaluators are in charge of evalutating a vector of individuals (i.e. running
          phen_t::fit::eval() for each individual).
        </para>
        <section id="documentation.reference.main_classes.evaluators.eval">
          <title><link linkend="documentation.reference.main_classes.evaluators.eval">Eval</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[file:~/svn/sferes2/trunk/sferes/eval/eval.hpp][sferes/eval/eval.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                A basic evaluator (no multiprocessing, no MPI, etc.), i.e. a basic
                loop.
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical typename:</emphasis>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">eval</phrase><phrase role="special">::</phrase><phrase role="identifier">Eval</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">;</phrase></programlisting>
          </para>
        </section>
        <section id="documentation.reference.main_classes.evaluators.parallel">
          <title><link linkend="documentation.reference.main_classes.evaluators.parallel">Parallel</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[file:~/svn/sferes2/trunk/sferes/eval/parallel.hpp][sferes/eval/parallel.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis> A SMP/multicore evaluator
                based on TBB ([[http://www.threadingbuildingblocks.org/]]). <emphasis
                role="bold">Your fitness should be thread-safe!</emphasis>
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical typename:</emphasis>
              </simpara>
            </listitem>
          </itemizedlist>
          <para>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">eval</phrase><phrase role="special">::</phrase><phrase role="identifier">Parallel</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">;</phrase></programlisting>
          </para>
        </section>
        <section id="documentation.reference.main_classes.evaluators.mpi">
          <title><link linkend="documentation.reference.main_classes.evaluators.mpi">Mpi</link></title>
          <itemizedlist>
            <listitem>
              <simpara>
                <emphasis role="bold">File:</emphasis> [[file:sferes/eval/mpi.hpp][sferes/eval/mpi.hpp]]
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Description:</emphasis> A MPI evaluator based
                on boost::mpi. It works on clusters (we use it on a JS22 cluster
                with IBM MPI).
              </simpara>
            </listitem>
            <listitem>
              <simpara>
                <emphasis role="bold">Typical typename:</emphasis>
<programlisting><phrase role="keyword">typedef</phrase> <phrase role="identifier">eval</phrase><phrase role="special">::</phrase><phrase role="identifier">Mpi</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Params</phrase><phrase role="special">&gt;</phrase> <phrase role="identifier">eval_t</phrase><phrase role="special">;</phrase></programlisting>
              </simpara>
            </listitem>
          </itemizedlist>
        </section>
        <section id="documentation.reference.main_classes.evaluators.defining_your_own_evaluator">
          <title><link linkend="documentation.reference.main_classes.evaluators.defining_your_own_evaluator">Defining
          your own evaluator</link></title>
          <para>
            The only required method is eval. It should call phen_t::develop() then
            phen_t::fit::eval() for each individual.
<programlisting><phrase role="keyword">namespace</phrase> <phrase role="identifier">sferes</phrase>
<phrase role="special">{</phrase>
  <phrase role="keyword">namespace</phrase> <phrase role="identifier">eval</phrase>
  <phrase role="special">{</phrase>
    <phrase role="identifier">SFERES_EVAL</phrase><phrase role="special">(</phrase><phrase role="identifier">Eval</phrase><phrase role="special">)</phrase>
    <phrase role="special">{</phrase>
    <phrase role="keyword">public</phrase><phrase role="special">:</phrase>
      <phrase role="keyword">template</phrase><phrase role="special">&lt;</phrase><phrase role="keyword">typename</phrase> <phrase role="identifier">Phen</phrase><phrase role="special">&gt;</phrase>
        <phrase role="keyword">void</phrase> <phrase role="identifier">eval</phrase><phrase role="special">(</phrase><phrase role="identifier">std</phrase><phrase role="special">::</phrase><phrase role="identifier">vector</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">boost</phrase><phrase role="special">::</phrase><phrase role="identifier">shared_ptr</phrase><phrase role="special">&lt;</phrase><phrase role="identifier">Phen</phrase><phrase role="special">&gt;</phrase> <phrase role="special">&gt;&amp;</phrase> <phrase role="identifier">pop</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">begin</phrase><phrase role="special">,</phrase> <phrase role="identifier">size_t</phrase> <phrase role="identifier">end</phrase><phrase role="special">)</phrase>
      <phrase role="special">{</phrase>
        <phrase role="keyword">for</phrase> <phrase role="special">(</phrase><phrase role="identifier">size_t</phrase> <phrase role="identifier">i</phrase> <phrase role="special">=</phrase> <phrase role="identifier">begin</phrase><phrase role="special">;</phrase> <phrase role="identifier">i</phrase> <phrase role="special">&lt;</phrase> <phrase role="identifier">end</phrase><phrase role="special">;</phrase> <phrase role="special">++</phrase><phrase role="identifier">i</phrase><phrase role="special">)</phrase>
          <phrase role="special">{</phrase>
            <phrase role="identifier">pop</phrase><phrase role="special">[</phrase><phrase role="identifier">i</phrase><phrase role="special">]-&gt;</phrase><phrase role="identifier">develop</phrase><phrase role="special">();</phrase>
            <phrase role="identifier">pop</phrase><phrase role="special">[</phrase><phrase role="identifier">i</phrase><phrase role="special">]-&gt;</phrase><phrase role="identifier">fit</phrase><phrase role="special">().</phrase><phrase role="identifier">eval</phrase><phrase role="special">(*</phrase><phrase role="identifier">pop</phrase><phrase role="special">[</phrase><phrase role="identifier">i</phrase><phrase role="special">]);</phrase>
          <phrase role="special">}</phrase>
      <phrase role="special">}</phrase>
    <phrase role="keyword">protected</phrase><phrase role="special">:</phrase>
    <phrase role="special">};</phrase>
  <phrase role="special">}</phrase>
<phrase role="special">}</phrase></programlisting>
          </para>
        </section>
      </section>
      <section id="documentation.reference.main_classes.modifiers">
        <title><link linkend="documentation.reference.main_classes.modifiers">Modifiers</link></title>
        <para>
          Modifiers are run once all the individuals have been evaluated but before
          any sorting. They are designed to allow to modify the fitness values to
          implement niching strategies, diversity preservation mechanisms, etc.
        </para>
        <para>
          The only predefined modifier available in sferes2 is modif::Dummy, which
          does nothing.
        </para>
      </section>
      <section id="documentation.reference.main_classes.dummy">
        <title><link linkend="documentation.reference.main_classes.dummy">Dummy</link></title>
        <itemizedlist>
          <listitem>
            <simpara>
              <emphasis role="bold">File:</emphasis> [[file:~/svn/sferes2/trunk/sferes/modif/dummy.hpp][sferes/modif/dummy.hpp]]
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              <emphasis role="bold">Description:</emphasis> basic modifier which
              does nothing. [endsect] [section Misc] The misc namespace contains
              useful small functions for:
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              system access (e.g getpid())
            </simpara>
          </listitem>
          <listitem>
            <simpara>
              random number generation
            </simpara>
          </listitem>
        </itemizedlist>
      </section>
      <section id="documentation.reference.main_classes.modules">
        <title><link linkend="documentation.reference.main_classes.modules">Modules</link></title>
        <section id="documentation.reference.main_classes.modules.nn">
          <title><link linkend="documentation.reference.main_classes.modules.nn">NN</link></title>
        </section>
        <section id="documentation.reference.main_classes.modules.fastsim">
          <title><link linkend="documentation.reference.main_classes.modules.fastsim">Fastsim</link></title>
        </section>
        <section id="documentation.reference.main_classes.modules.python">
          <title><link linkend="documentation.reference.main_classes.modules.python">Python</link></title>
        </section>
      </section>
    </section>
  </section>
</book>
